"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[5895],{3905:(e,n,t)=>{t.d(n,{Zo:()=>s,kt:()=>h});var a=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function p(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var o=a.createContext({}),c=function(e){var n=a.useContext(o),t=n;return e&&(t="function"==typeof e?e(n):p(p({},n),e)),t},s=function(e){var n=c(e.components);return a.createElement(o.Provider,{value:n},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,i=e.originalType,o=e.parentName,s=l(e,["components","mdxType","originalType","parentName"]),d=c(t),m=r,h=d["".concat(o,".").concat(m)]||d[m]||u[m]||i;return t?a.createElement(h,p(p({ref:n},s),{},{components:t})):a.createElement(h,p({ref:n},s))}));function h(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=t.length,p=new Array(i);p[0]=m;var l={};for(var o in n)hasOwnProperty.call(n,o)&&(l[o]=n[o]);l.originalType=e,l[d]="string"==typeof e?e:r,p[1]=l;for(var c=2;c<i;c++)p[c]=t[c];return a.createElement.apply(null,p)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},1597:(e,n,t)=>{t.r(n),t.d(n,{default:()=>u,frontMatter:()=>l,metadata:()=>o,toc:()=>c});var a=t(7462),r=t(3366),i=(t(7294),t(3905)),p=["components"],l={id:"replace",title:"Replacing overview"},o={unversionedId:"replace",id:"replace",isDocsHomePage:!1,title:"Replacing overview",description:"Documentation for version: 0.41.2",source:"@site/../docs/replace.mdx",sourceDirName:".",slug:"/replace",permalink:"/docs/replace",version:"current",lastUpdatedAt:1682633299,formattedLastUpdatedAt:"4/27/2023",frontMatter:{id:"replace",title:"Replacing overview"},sidebar:"docs",previous:{title:"Handling integers",permalink:"/docs/match-as-int"},next:{title:"Replace limits",permalink:"/docs/replace-limit"}},c=[{value:"Replacing with a constant value",id:"replacing-with-a-constant-value",children:[{value:"Replacing with an empty string",id:"replacing-with-an-empty-string",children:[]}]},{value:"Replace with a group",id:"replace-with-a-group",children:[{value:"Named groups",id:"named-groups",children:[]},{value:"Unmatched group",id:"unmatched-group",children:[]},{value:"Nonexistent group",id:"nonexistent-group",children:[]}]},{value:"Replace with a callback",id:"replace-with-a-callback",children:[{value:"Matched occurrence",id:"matched-occurrence",children:[]},{value:"Accepted return values",id:"accepted-return-values",children:[]},{value:"<code>Stringable</code> return values",id:"stringable-return-values",children:[]},{value:"PHP callable notation",id:"php-callable-notation",children:[]}]},{value:"Replace with references",id:"replace-with-references",children:[]}],s={toc:c},d="wrapper";function u(e){var n=e.components,t=(0,r.Z)(e,p);return(0,i.kt)(d,(0,a.Z)({},s,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Documentation for version: 0.41.2"),(0,i.kt)("p",null,"Use ",(0,i.kt)("inlineCode",{parentName:"p"},"Pattern.replace()")," to perform regular expression search and replace."),(0,i.kt)("h2",{id:"replacing-with-a-constant-value"},"Replacing with a constant value"),(0,i.kt)("p",null,"To replace occurrences of a regular expression pattern in a given subject, use ",(0,i.kt)("inlineCode",{parentName:"p"},"Pattern.replace()")," to\ninstantiate a ",(0,i.kt)("inlineCode",{parentName:"p"},"Replace")," operation for the subject and ",(0,i.kt)("inlineCode",{parentName:"p"},".with()")," to replace the ocurrence with a constant\n",(0,i.kt)("inlineCode",{parentName:"p"},"string")," value."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-php"},"// Instantiate a pattern\n$pattern = Pattern::of('\\w{4,}', 'i');\n\n// instantiate a replace operation\n$replace = $pattern->replace('Some of these words are longer');\n\n// perform regular expression search and replace\n$output = $replace->with('XXX');  // (string) \"XXX of XXX XXX are XXX\"\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"Replace.with()")," returns a new string with content of the subject, but with occurrences of a\nregular expression replaced by a given ",(0,i.kt)("inlineCode",{parentName:"p"},"string")," argument."),(0,i.kt)("p",null,"If the pattern doesn't match the subject at all, ",(0,i.kt)("inlineCode",{parentName:"p"},".with()")," returns the subject unmodified."),(0,i.kt)("h3",{id:"replacing-with-an-empty-string"},"Replacing with an empty string"),(0,i.kt)("p",null,"While it is possible to call ",(0,i.kt)("inlineCode",{parentName:"p"},"Replace.with()")," with an empty string ",(0,i.kt)("inlineCode",{parentName:"p"},'""')," to remove the occurrences,\nit's more semantic to call ",(0,i.kt)("inlineCode",{parentName:"p"},"Pattern.prune()"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-php"},"// Instantiate a pattern\n$pattern = Pattern::of('\\w{4,}', 'i');\n\n// using Replace.with()   \ud83d\uddd9 \n$replace = $pattern->replace('Some of these words are longer');\n$output = $replace->with('');  // replace with an empty string\n\n// using Pattern.prune()  \u2713 \n$output = $pattern->prune('Some of these words are longer');\n")),(0,i.kt)("h2",{id:"replace-with-a-group"},"Replace with a group"),(0,i.kt)("p",null,"Method ",(0,i.kt)("inlineCode",{parentName:"p"},"Replace.withGroup()")," can be used to replace occurrences of a regular expression in the\nsubject with a capturing group of the expression. To replace the occurrence of regular expression\nin the subject with a capturing group, pass an ordinal number of the group as the first argument\nof ",(0,i.kt)("inlineCode",{parentName:"p"},"Replace.withGroup()"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-php"},"// Instantiate a pattern with a capturing group\n$domainPattern = Pattern::of('www\\.([\\w.-]+)', 'i');\n\n// instantiate a replace operation\n$replace = $domainPattern->replace('I have a link: www.google.com and www.t-regx.com');\n\n// replace domain with just the top level domain\n$output = $replace->withGroup(1);  // (string) \"I have a link: google.com and t-regx.com\"\n")),(0,i.kt)("p",null,"The regular expression ",(0,i.kt)("inlineCode",{parentName:"p"},"www.([\\w.-]+)")," matches substring ",(0,i.kt)("inlineCode",{parentName:"p"},'"www.google.com"'),", in which\nthe capturing group ",(0,i.kt)("inlineCode",{parentName:"p"},"1")," captures ",(0,i.kt)("inlineCode",{parentName:"p"},'"google.com"'),". Replacement operation is invoked using ",(0,i.kt)("inlineCode",{parentName:"p"},"withGroup(1)"),",\nand so the matched occurrence is replaced by the content of the capturing group. The second\noccurrence of the matched pattern is ",(0,i.kt)("inlineCode",{parentName:"p"},'"www.t-regx.com"'),", in which the first capturing group\ncaptures ",(0,i.kt)("inlineCode",{parentName:"p"},'"t-regx.com"'),"."),(0,i.kt)("p",null,"Method ",(0,i.kt)("inlineCode",{parentName:"p"},"Replace.withGroup()")," accepts ",(0,i.kt)("inlineCode",{parentName:"p"},"int|string"),". With argument of type ",(0,i.kt)("inlineCode",{parentName:"p"},"int")," passed, the capturing\ngroup is referred to by an ordinal number, commonly known as ",(0,i.kt)("em",{parentName:"p"},'"group index"'),". Capturing groups are\nordered by their opening parenthesis. For example: in pattern ",(0,i.kt)("inlineCode",{parentName:"p"},"(Cat)(Foo(Bar))"),", group ",(0,i.kt)("inlineCode",{parentName:"p"},"(Cat)")," is\nassigned an ordinal number ",(0,i.kt)("inlineCode",{parentName:"p"},"1"),", group ",(0,i.kt)("inlineCode",{parentName:"p"},"(Foo(Bar))")," is assigned an ordinal number ",(0,i.kt)("inlineCode",{parentName:"p"},"2"),", and group ",(0,i.kt)("inlineCode",{parentName:"p"},"(Bar)"),"\nis assigned an ordinal number ",(0,i.kt)("inlineCode",{parentName:"p"},"3"),"."),(0,i.kt)("p",null,"Because the matched occurrence is always implicitly captured and is assigned an ordinal number ",(0,i.kt)("inlineCode",{parentName:"p"},"0"),",\ncall ",(0,i.kt)("inlineCode",{parentName:"p"},"Replace.withGroup(0)")," performs a somewhat redundant search and replace, because it returns the\nsubject unmodified, as the matched occurrence is replaced by itself."),(0,i.kt)("h3",{id:"named-groups"},"Named groups"),(0,i.kt)("p",null,"Method ",(0,i.kt)("inlineCode",{parentName:"p"},"Replace.withGroup()")," accepts ",(0,i.kt)("inlineCode",{parentName:"p"},"int|string"),". With argument of type ",(0,i.kt)("inlineCode",{parentName:"p"},"string")," passed, the capturing\ngroup is referred to by its group name. Not all capturing groups are named, for example group ",(0,i.kt)("inlineCode",{parentName:"p"},"(Foo)"),"\nis not a named group."),(0,i.kt)("p",null,"Explicit syntax is available for named groups: ",(0,i.kt)("inlineCode",{parentName:"p"},"(?<###>...)"),", where ",(0,i.kt)("inlineCode",{parentName:"p"},"###")," is the name of the group,\nfor example: ",(0,i.kt)("inlineCode",{parentName:"p"},"(?<capital>[A-Z])[a-z]+)"),". Alternative syntax for named group is ",(0,i.kt)("inlineCode",{parentName:"p"},"(?P<###>...)")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"(?'###'...)"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-php"},"// Instantiate a pattern with a named capturing group\n$domainPattern = Pattern::of('(?<capital>[A-Z])[a-z]{2,})');\n\n// instantiate a replace operation\n$replace = $domainPattern->replace('My name is Mark, and his name is John');\n\n// replace names with their capital letters\n$output = $replace->withGroup('capital');  // (string) \"My name is M, and his name is J\"\n")),(0,i.kt)("p",null,"Named capturing groups can be referred to either by ordinal numbers or by the name. In pattern\n",(0,i.kt)("inlineCode",{parentName:"p"},"(?<capital>[A-Z])[a-z]{2,})"),", the first group can be used to replace the occurrence either\nusing ",(0,i.kt)("inlineCode",{parentName:"p"},"withGroup(1)")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"withGroup('capital')"),". In other words, all capturing groups are assigned\nan ordinal number, but only named groups can be referred to by their name."),(0,i.kt)("p",null,"Additionally, modifier ",(0,i.kt)("inlineCode",{parentName:"p"},"/n")," can be used when instantiating ",(0,i.kt)("inlineCode",{parentName:"p"},"Pattern")," by passing ",(0,i.kt)("inlineCode",{parentName:"p"},"Pattern::NO_AUTOCAPTURE"),"\nor by simply passing ",(0,i.kt)("inlineCode",{parentName:"p"},"string")," literal ",(0,i.kt)("inlineCode",{parentName:"p"},"'n'")," ."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-php"},"$pattern = Pattern::of('(https?://)?(?<domain>[\\w.]+)', Pattern::NO_AUTOCAPTURE);\n$pattern = Pattern::of('(https?://)?(?<domain>[\\w.]+)', 'n');\n")),(0,i.kt)("p",null,"Because modifier ",(0,i.kt)("inlineCode",{parentName:"p"},"Pattern::NO_AUTOCAPTURE")," is used in ",(0,i.kt)("inlineCode",{parentName:"p"},"$pattern"),", only the named groups are\ncaptured, and so group ",(0,i.kt)("inlineCode",{parentName:"p"},"(https?://)")," is not captured. In this case ",(0,i.kt)("inlineCode",{parentName:"p"},"(?<domain>[\\w.]+)")," is\ncaptured and is assigned an ordinal number ",(0,i.kt)("inlineCode",{parentName:"p"},"1"),". "),(0,i.kt)("p",null,"In patterns without modifier ",(0,i.kt)("inlineCode",{parentName:"p"},"'n'")," - ",(0,i.kt)("inlineCode",{parentName:"p"},"Pattern::NO_AUTOCAPTURE"),", syntax ",(0,i.kt)("inlineCode",{parentName:"p"},"(?:...)")," can be\nused to add a non-capturing group."),(0,i.kt)("h3",{id:"unmatched-group"},"Unmatched group"),(0,i.kt)("p",null,"Method ",(0,i.kt)("inlineCode",{parentName:"p"},"Replace.withGroup()")," throws ",(0,i.kt)("inlineCode",{parentName:"p"},"GroupNotMatchedException")," when replacement is attempted with\nan unmatched group."),(0,i.kt)("p",null,"In example below, group ",(0,i.kt)("inlineCode",{parentName:"p"},"(http://)")," is followed by ",(0,i.kt)("inlineCode",{parentName:"p"},"?"),". Such group may not be matched, while the\nwhole pattern matches. Such groups are referred to as ",(0,i.kt)("em",{parentName:"p"},'"optional groups"'),", because for different\nsubjects they may or may not be matched."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-php"},"// Instantiate a pattern\n$domainPattern = Pattern::of('(http://)?www.[\\w.-]+');\n\n// instantiate a replace\n$replace = $domainPattern->replace('I have a link: www.google.com and www.t-regx.com');\n\n// try to replace with an unmatched group\n$output = $replace->withGroup(1);  // (GroupNotMatchedException): Expected to replace with group #1, but the group was not matched\n")),(0,i.kt)("h3",{id:"nonexistent-group"},"Nonexistent group"),(0,i.kt)("p",null,"Method ",(0,i.kt)("inlineCode",{parentName:"p"},"Replace.withGroup()")," throws ",(0,i.kt)("inlineCode",{parentName:"p"},"NonexistentGroupException")," when replacement is attempted with\na group that is not present in the pattern."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-php"},"// Instantiate a pattern\n$domainPattern = Pattern::of('(http://)?www.[\\w.]+');\n\n// instantiate a replace\n$replace = $domainPattern->replace('subject');\n\n// try to replace with a nonexistent group\n$output = $replace->withGroup(3);          // (NonexistentGroupException): Nonexistent group: #3\n$output = $replace->withGroup('missing');  // (NonexistentGroupException): Nonexistent group: 'missing'\n")),(0,i.kt)("p",null,"In fact, any operation on a missing group apart from ",(0,i.kt)("inlineCode",{parentName:"p"},".groupExists()")," throws ",(0,i.kt)("inlineCode",{parentName:"p"},"NonexistentGroupException"),"."),(0,i.kt)("h2",{id:"replace-with-a-callback"},"Replace with a callback"),(0,i.kt)("p",null,"Method ",(0,i.kt)("inlineCode",{parentName:"p"},"Replace.callback()")," performs a regular expression search, passes the flow control back\nto the caller via ",(0,i.kt)("inlineCode",{parentName:"p"},"callable"),", which accepts a matched occurrence as ",(0,i.kt)("inlineCode",{parentName:"p"},"Detail")," argument, and then\nperforms replacement with the values returned from the ",(0,i.kt)("inlineCode",{parentName:"p"},"callable"),". Each matched occurrence of the\nregular expression in the subject is replaced by ",(0,i.kt)("inlineCode",{parentName:"p"},"string")," value returned from the ",(0,i.kt)("inlineCode",{parentName:"p"},"callable"),". In\nother words, ",(0,i.kt)("inlineCode",{parentName:"p"},"Replace.callback()")," accepts a ",(0,i.kt)("inlineCode",{parentName:"p"},"callable"),", which is supposed to map the received\n",(0,i.kt)("inlineCode",{parentName:"p"},"Detail")," argument to a new ",(0,i.kt)("inlineCode",{parentName:"p"},"string")," replacement."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-php"},"// Instantiate a pattern\n$pattern = Pattern::of('[A-Z][a-z]+'); \n\n// instantiate a replace\n$replace = $pattern->replace('I like scandinavia: Sweden, Norway and Denmark');\n\n// replace occurrences with a callback\n$replace->callback(fn (Detail $match) => \\strToUpper($match->text())); \n  // (string) \"I like scandinavia: SWEDEN, NORWAY and DENMARK\"\n")),(0,i.kt)("h3",{id:"matched-occurrence"},"Matched occurrence"),(0,i.kt)("p",null,"The matched occurrence of the regular expression in the subject is passed as an argument\nto the ",(0,i.kt)("inlineCode",{parentName:"p"},"callable")," argument of ",(0,i.kt)("inlineCode",{parentName:"p"},"Replace.callback()"),"."),(0,i.kt)("p",null,"The matched occurrence is passed as ",(0,i.kt)("inlineCode",{parentName:"p"},"Detail"),", which is the same interface as the one\nrepresenting the matched occurrence in ",(0,i.kt)("inlineCode",{parentName:"p"},"Pattern.match()"),", for example ",(0,i.kt)("inlineCode",{parentName:"p"},"Matcher.first()"),"."),(0,i.kt)("p",null,"All of the implementation differences between internal structures of matching and replacing\nare unified under the common ",(0,i.kt)("inlineCode",{parentName:"p"},"Detail")," interface."),(0,i.kt)("h3",{id:"accepted-return-values"},"Accepted return values"),(0,i.kt)("p",null,"Argument ",(0,i.kt)("inlineCode",{parentName:"p"},"callable")," passed to ",(0,i.kt)("inlineCode",{parentName:"p"},"Replace.callback()")," can only return ",(0,i.kt)("inlineCode",{parentName:"p"},"string"),", which is the\nnew replacement."),(0,i.kt)("p",null,"When value of type other than ",(0,i.kt)("inlineCode",{parentName:"p"},"string")," is returned from the ",(0,i.kt)("inlineCode",{parentName:"p"},"callable"),", then ",(0,i.kt)("inlineCode",{parentName:"p"},"Replace.callback()"),"\nthrows ",(0,i.kt)("inlineCode",{parentName:"p"},"InvalidReplacementException"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-php"},"$pattern = Pattern::of('[A-Z][a-z]+');\n$replace = $pattern->replace('I like scandinavia: Sweden, Norway and Denmark');\n\n$replace->callback(function (Detail $match): int {\n    return 2;\n});\n  // (InvalidReplacementException): Invalid callback() callback return type. Expected string, but integer (2) given\n")),(0,i.kt)("h3",{id:"stringable-return-values"},(0,i.kt)("inlineCode",{parentName:"h3"},"Stringable")," return values"),(0,i.kt)("p",null,"Note, that objects implementing ",(0,i.kt)("inlineCode",{parentName:"p"},"Stringable")," or objects with ",(0,i.kt)("inlineCode",{parentName:"p"},"__toString()")," are also invalid."),(0,i.kt)("p",null,"Received argument ",(0,i.kt)("inlineCode",{parentName:"p"},"Detail")," can be cast to ",(0,i.kt)("inlineCode",{parentName:"p"},"string"),", which is the same as calling ",(0,i.kt)("inlineCode",{parentName:"p"},"Detail.text()"),";\nbut returning object of type ",(0,i.kt)("inlineCode",{parentName:"p"},"Detail")," or any other ",(0,i.kt)("inlineCode",{parentName:"p"},"Stringable")," object throws\n",(0,i.kt)("inlineCode",{parentName:"p"},"InvalidReplacementException"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-php"},'$replace->callback(function (Detail $match): Detail {\n    $match->text();  // (string) "Sweden"\n    (string) $match; // (string) "Sweden"\n\n    return $match;\n});\n    // (InvalidReplacementException): Invalid callback() callback return type. Expected string, but...\n')),(0,i.kt)("p",null,"To conveniently return object of type ",(0,i.kt)("inlineCode",{parentName:"p"},"Detail")," or other ",(0,i.kt)("inlineCode",{parentName:"p"},"Stringable")," type, specify PHP ",(0,i.kt)("inlineCode",{parentName:"p"},"string"),"\ntype-hint on the anonymous function or explicitly cast the object to ",(0,i.kt)("inlineCode",{parentName:"p"},"string"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-php"},"$replace->callback(function (Detail $match) {\n    return (string) $match; // explicit cast to string\n});\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-php"},'$replace->callback(function (Detail $match): string { // PHP "string" type-hint\n    return $match;\n});\n')),(0,i.kt)("p",null,"Specify ",(0,i.kt)("inlineCode",{parentName:"p"},"string")," type-hint, so that PHP can implicitly cast the object to ",(0,i.kt)("inlineCode",{parentName:"p"},"string"),",\nor omit the type-hint and allow ",(0,i.kt)("inlineCode",{parentName:"p"},"Replace.callback()")," to validate the type of the return values,\nin case the returned value is of other type."),(0,i.kt)("h3",{id:"php-callable-notation"},"PHP callable notation"),(0,i.kt)("p",null,"In PHP, certain ",(0,i.kt)("inlineCode",{parentName:"p"},"string")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"array")," values are also ",(0,i.kt)("inlineCode",{parentName:"p"},"callable"),". "),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"'strToUpper'"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"'strToLower'")," - a ",(0,i.kt)("inlineCode",{parentName:"li"},"callable")," that behaves similarly to global ",(0,i.kt)("inlineCode",{parentName:"li"},"strToUpper()")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"strToLower()")," functions"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"[$this, 'replace']")," - a ",(0,i.kt)("inlineCode",{parentName:"li"},"callable")," tht behaves similarly to a method ",(0,i.kt)("inlineCode",{parentName:"li"},".replace()")," on ",(0,i.kt)("inlineCode",{parentName:"li"},"$this"))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-php"},"// Instantiate a pattern\n$pattern = Pattern::of('[A-Z][a-z]+'); \n\n// instantiate a replace\n$replace = $pattern->replace('I like scandinavia: Sweden, Norway and Denmark');\n\n// replace occurrences with a callback\n$replace->callback('strToUpper'); // (string) \"I like scandinavia: SWEDEN, NORWAY and DENMARK\"\n")),(0,i.kt)("p",null,"Function ",(0,i.kt)("inlineCode",{parentName:"p"},"strToUpper()")," accepts ",(0,i.kt)("inlineCode",{parentName:"p"},"string")," as argument, and so when ",(0,i.kt)("inlineCode",{parentName:"p"},"callback('strToUpper')")," is called,\nthe ",(0,i.kt)("inlineCode",{parentName:"p"},"Detail")," is passed as an argument to ",(0,i.kt)("inlineCode",{parentName:"p"},"strToUpper()"),". Because ",(0,i.kt)("inlineCode",{parentName:"p"},"strToUpper()")," accepts ",(0,i.kt)("inlineCode",{parentName:"p"},"string"),", then\n",(0,i.kt)("inlineCode",{parentName:"p"},"Detail")," is being cast to ",(0,i.kt)("inlineCode",{parentName:"p"},"string"),", which is the same as calling ",(0,i.kt)("inlineCode",{parentName:"p"},"Detail.text()"),"."),(0,i.kt)("p",null,"In PHP, an array ",(0,i.kt)("inlineCode",{parentName:"p"},"[$this, 'replace']")," is also a valid ",(0,i.kt)("inlineCode",{parentName:"p"},"callable"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-php"},"class HelloWorld {\n    public function run() {\n        // Instantiate a pattern\n        $pattern = Pattern::of('[A-Z][a-z]+'); \n        \n        // instantiate a replace\n        $replace = $pattern->replace('I like scandinavia: Sweden, Norway and Denmark');\n        \n        // replace occurrences with a callback\n        $replace->callback([$this, 'replace']); // (string) \"I like scandinavia: SWEDEN, NORWAY and DENMARK\"\n    }\n\n    private function replace(Detail $match): string {\n        return \\strToUpper($match->text());\n    }\n}\n")),(0,i.kt)("p",null,"Notice, that ",(0,i.kt)("inlineCode",{parentName:"p"},"Replace.callback()")," truly accepts ",(0,i.kt)("inlineCode",{parentName:"p"},"callable")," as argument type. However, in PHP certain\nvalues are also regarded as callable, for instance the aforementioned ",(0,i.kt)("inlineCode",{parentName:"p"},'"strToUpper"')," or\n",(0,i.kt)("inlineCode",{parentName:"p"},"[$this, 'replace']"),"."),(0,i.kt)("h2",{id:"replace-with-references"},"Replace with references"),(0,i.kt)("p",null,"Method ",(0,i.kt)("inlineCode",{parentName:"p"},"Replace.withReferences()")," can be used to pass a formatting string to PCRE, which is an internal\nimplementation of T-Regx and other regular expression methods in PHP."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"Replace.withReferences()")," is listed last, as this is the least recommended mean of replacing elements.\nPlease, try and use ",(0,i.kt)("inlineCode",{parentName:"p"},".with()"),", ",(0,i.kt)("inlineCode",{parentName:"p"},".withGroup()")," or ",(0,i.kt)("inlineCode",{parentName:"p"},".callback()")," first, and only use ",(0,i.kt)("inlineCode",{parentName:"p"},".withReferences()"),"\nas the last resort."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-php"},"// Instantiate a pattern\n$domainPattern = Pattern::of('(?:(https?)://)?www.[\\w.-]+');\n\n// instantiate a replace\n$replace = $domainPattern->replace('I have a link: https://www.google.com and www.t-regx.com');\n\n// replace with a formatting string\n$output = $replace->withReferences('<scheme:$1>'); // (string) \"I have a link: <scheme:https> and <scheme:>\"\n")),(0,i.kt)("p",null,"Method ",(0,i.kt)("inlineCode",{parentName:"p"},"Replace.withReferences()")," replaces the matched occurrences with the formatting string,\nwith certain tokens populated by captured groups, for example: ",(0,i.kt)("inlineCode",{parentName:"p"},"$1"),"."),(0,i.kt)("p",null,"Special tokens in formatting string:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"$")," and a capturing group ordinal number: ",(0,i.kt)("inlineCode",{parentName:"li"},"$1"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"$2")," and also ",(0,i.kt)("inlineCode",{parentName:"li"},"$0")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"\\")," and a capturing group ordinal number: ",(0,i.kt)("inlineCode",{parentName:"li"},"\\1"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"\\2")," and also ",(0,i.kt)("inlineCode",{parentName:"li"},"\\0")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"${"),", a group ordinal number and a closing ",(0,i.kt)("inlineCode",{parentName:"li"},"}"),": ",(0,i.kt)("inlineCode",{parentName:"li"},"${1}"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"${2}")," and also ",(0,i.kt)("inlineCode",{parentName:"li"},"${0}"))),(0,i.kt)("p",null,"Please, be advised that ",(0,i.kt)("inlineCode",{parentName:"p"},"Replace.withReferences()")," is discouraged, because of a number of reasons:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Formatting string tokens use special characters which can be mistaken for PHP language syntax (e.g. for example\nformat token ",(0,i.kt)("inlineCode",{parentName:"li"},"\\1")," can be mistaken for PHP notation of ",(0,i.kt)("inlineCode",{parentName:"li"},"chr(1)"),")"),(0,i.kt)("li",{parentName:"ul"},"Unmatched groups are simply ignored, and implicitly replaced by an empty string ",(0,i.kt)("inlineCode",{parentName:"li"},'""'),", which may or may not be desired"),(0,i.kt)("li",{parentName:"ul"},"Nonexistent groups are ignored, which can lead to hard to find bugs"),(0,i.kt)("li",{parentName:"ul"},"Formatting string can't be used to reference capturing groups by names"),(0,i.kt)("li",{parentName:"ul"},"Is a tight dependency on internal PCRE format")),(0,i.kt)("p",null,"For these reasons we recommend using ",(0,i.kt)("inlineCode",{parentName:"p"},".with()"),", ",(0,i.kt)("inlineCode",{parentName:"p"},".withGroup()")," and ",(0,i.kt)("inlineCode",{parentName:"p"},".callback()"),"."))}u.isMDXComponent=!0}}]);