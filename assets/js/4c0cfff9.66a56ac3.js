"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[6076],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>h});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function p(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var o=a.createContext({}),s=function(e){var t=a.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},d=function(e){var t=s(e.components);return a.createElement(o.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,o=e.parentName,d=p(e,["components","mdxType","originalType","parentName"]),m=s(n),h=r,u=m["".concat(o,".").concat(h)]||m[h]||c[h]||i;return n?a.createElement(u,l(l({ref:t},d),{},{components:n})):a.createElement(u,l({ref:t},d))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,l=new Array(i);l[0]=m;var p={};for(var o in t)hasOwnProperty.call(t,o)&&(p[o]=t[o]);p.originalType=e,p.mdxType="string"==typeof e?e:r,l[1]=p;for(var s=2;s<i;s++)l[s]=n[s];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},994:(e,t,n)=>{n.r(t),n.d(t,{default:()=>c,frontMatter:()=>p,metadata:()=>o,toc:()=>s});var a=n(7462),r=n(3366),i=(n(7294),n(3905)),l=["components"],p={id:"template-syntax",title:"Template Syntax"},o={unversionedId:"template-syntax",id:"template-syntax",isDocsHomePage:!1,title:"Template Syntax",description:"Documentation for version: 0.39.0",source:"@site/../docs/template-syntax.md",sourceDirName:".",slug:"/template-syntax",permalink:"/docs/template-syntax",version:"current",lastUpdatedAt:1669403024,formattedLastUpdatedAt:"11/25/2022",frontMatter:{id:"template-syntax",title:"Template Syntax"},sidebar:"docs",previous:{title:"Prepared Patterns - Introduction",permalink:"/docs/prepared-patterns"},next:{title:"Multiple patterns",permalink:"/docs/pattern-list"}},s=[{value:"Placeholder in regular expression",id:"placeholder-in-regular-expression",children:[]},{value:"Literal usage of <code>&quot;@&quot;</code> in the template",id:"literal-usage-of--in-the-template",children:[{value:"Backslash before the placeholder",id:"backslash-before-the-placeholder",children:[]}]},{value:"Quantified placeholders",id:"quantified-placeholders",children:[{value:"Quantifier <code>?</code>",id:"quantifier-",children:[]},{value:"Quantifier <code>+</code>",id:"quantifier--1",children:[]},{value:"Quantifier after an empty bound figure",id:"quantifier-after-an-empty-bound-figure",children:[]}]},{value:"Capturing placeholders",id:"capturing-placeholders",children:[]},{value:"Character <code>@</code> in a character class",id:"character--in-a-character-class",children:[]},{value:"Comments",id:"comments",children:[{value:"Group comments",id:"group-comments",children:[]},{value:"Comments and <code>/x</code> modifier",id:"comments-and-x-modifier",children:[]}]},{value:"Quote with <code>Q</code> and <code>E</code>",id:"quote-with-q-and-e",children:[]},{value:"Improper usage of <code>@</code> placeholder",id:"improper-usage-of--placeholder",children:[]},{value:"Summary",id:"summary",children:[]}],d={toc:s};function c(e){var t=e.components,n=(0,r.Z)(e,l);return(0,i.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Documentation for version: 0.39.0"),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},'"Template"')," in prepared patterns terminology is simply a regular expression\nwith placeholders ",(0,i.kt)("inlineCode",{parentName:"p"},"@"),". "),(0,i.kt)("p",null,"The choosing of ",(0,i.kt)("inlineCode",{parentName:"p"},'"@"')," character as the placeholder is intentional. PHP uses PCRE\n(Perl-Compatible Regular Expressions) internally as the regular expressions engine.\nCharacter ",(0,i.kt)("inlineCode",{parentName:"p"},"@")," in Perl language is variable interpolation. Despite no technological\nconnection with Perl, the selection of ",(0,i.kt)("inlineCode",{parentName:"p"},"@")," seams appropriate."),(0,i.kt)("p",null,"When used with entry points ",(0,i.kt)("inlineCode",{parentName:"p"},"Pattern::inject()")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"Pattern::template()"),", placeholders\n",(0,i.kt)("inlineCode",{parentName:"p"},"@")," match whatever characters or figures are bound to the placeholders when the prepared\npattern is instantiated."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-php"},"$animalPattern = Pattern::inject('^(my|your) @$', ['cat?']);  // 'cat?' is bound to the first placeholder\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"Pattern")," in ",(0,i.kt)("inlineCode",{parentName:"p"},"$animalPattern")," matches ",(0,i.kt)("inlineCode",{parentName:"p"},'"my cat?"')," or ",(0,i.kt)("inlineCode",{parentName:"p"},'"your cat?"'),", but not\n",(0,i.kt)("inlineCode",{parentName:"p"},'"my ca"')," (because regular expression quantifier ",(0,i.kt)("inlineCode",{parentName:"p"},"?")," is not treated as an expression,\nbut literally as character ",(0,i.kt)("inlineCode",{parentName:"p"},'"?"'),"). "),(0,i.kt)("p",null,"Following the expression step by step, we find that ",(0,i.kt)("inlineCode",{parentName:"p"},"^")," matches the start of the subject,\n",(0,i.kt)("inlineCode",{parentName:"p"},"(my|your)")," matches either ",(0,i.kt)("inlineCode",{parentName:"p"},'"my"')," or ",(0,i.kt)("inlineCode",{parentName:"p"},'"your"'),", then space matches the space character ",(0,i.kt)("inlineCode",{parentName:"p"},'" "'),",\nplaceholder ",(0,i.kt)("inlineCode",{parentName:"p"},"@")," matches the string ",(0,i.kt)("inlineCode",{parentName:"p"},'"cat?"')," literally, and assertion ",(0,i.kt)("inlineCode",{parentName:"p"},"$")," matches the end\nof the subject."),(0,i.kt)("p",null,"The programming interface of prepared patterns is described in the previous chapter:\n",(0,i.kt)("a",{parentName:"p",href:"/docs/prepared-patterns"},"Prepared patterns - Overview"),". This chapter ",(0,i.kt)("a",{parentName:"p",href:"/docs/template-syntax"},"Template syntax"),"\nis dedicated solely to the template syntax and behaviour and meaning of ",(0,i.kt)("inlineCode",{parentName:"p"},"@")," used in the\ntemplate. The ",(0,i.kt)("a",{parentName:"p",href:"#summary"},"Summary")," is available at the end of the chapter."),(0,i.kt)("p",null,"The template syntax is the same for every prepared pattern entry-point, including:\n",(0,i.kt)("inlineCode",{parentName:"p"},"Pattern::inject()"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"Pattern::template()")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Pattern::builder()"),". Examples in this chapter\nmostly illustrate ",(0,i.kt)("inlineCode",{parentName:"p"},"Pattern::inject()"),", but all of the rules apply to ",(0,i.kt)("inlineCode",{parentName:"p"},"Pattern::template()"),"\nand ",(0,i.kt)("inlineCode",{parentName:"p"},"Pattern::builder()")," accordingly."),(0,i.kt)("h2",{id:"placeholder-in-regular-expression"},"Placeholder in regular expression"),(0,i.kt)("p",null,"Placeholder ",(0,i.kt)("inlineCode",{parentName:"p"},"@")," used in template behaves very similarly to standard regular expression\nfigures. It can be escaped, used in a character class, quantified, used in a capturing group,\natomic group, look-aheads/look-behinds; used in a group comment, extended comment syntax, in\na quote and as a control character."),(0,i.kt)("p",null,"Standard usage of placeholder ",(0,i.kt)("inlineCode",{parentName:"p"},"@")," is to bind a figure to be used in the regular expression."),(0,i.kt)("p",null,"In this example, we'll try to match the contents of ",(0,i.kt)("inlineCode",{parentName:"p"},"$content")," enclosed between forward slashes or\nbackslashes (so we want to match either ",(0,i.kt)("inlineCode",{parentName:"p"},'"/word/"')," or ",(0,i.kt)("inlineCode",{parentName:"p"},'"\\word\\"'),", but not ",(0,i.kt)("inlineCode",{parentName:"p"},'"/word\\"')," nor ",(0,i.kt)("inlineCode",{parentName:"p"},'"\\word/"'),"):"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-php"},"$content = '.?!';\n$enclosed = Pattern::inject(\"([\\\\\\\\/])@\\1\", [$content]);\n")),(0,i.kt)("p",null,"Pattern ",(0,i.kt)("inlineCode",{parentName:"p"},"$enclosed")," matches either string ",(0,i.kt)("inlineCode",{parentName:"p"},'"/.?!/"')," or string ",(0,i.kt)("inlineCode",{parentName:"p"},'"\\.?!\\"'),", but not ",(0,i.kt)("inlineCode",{parentName:"p"},'"\\.?!/"'),".\nNotice, that while ",(0,i.kt)("inlineCode",{parentName:"p"},"."),", ",(0,i.kt)("inlineCode",{parentName:"p"},"?")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"!")," are regular expression special characters, they're matched\nliterally when they're bound to the placeholder."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-php"},"$content = '.?!';\n$enclosed = Pattern::inject('([\\\\\\\\/])@\\1', [$content]);\n\n$search = $enclosed->search(\"/.?!/ and other \\.?! and \\.?!\\ and maybe /.?!\\\");\n\nvar_dump($search->all());\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},'array(2) {\n  [0]=>\n  string(5) "/.?!/"\n  [1]=>\n  string(5) "\\.?!\\"\n}\n')),(0,i.kt)("p",null,"Try and run prepared patterns examples online, right in your browser: ",(0,i.kt)("a",{parentName:"p",href:"/replit"},"Try online"),"."),(0,i.kt)("h2",{id:"literal-usage-of--in-the-template"},"Literal usage of ",(0,i.kt)("inlineCode",{parentName:"h2"},'"@"')," in the template"),(0,i.kt)("p",null,"Like every other regular expression figure, so can ",(0,i.kt)("inlineCode",{parentName:"p"},"@")," be escaped, in order to represent a\nliteral ",(0,i.kt)("inlineCode",{parentName:"p"},'"@"')," character. Escaping the placeholder revokes its meaning, and thus ",(0,i.kt)("inlineCode",{parentName:"p"},"\\@")," matches\n",(0,i.kt)("inlineCode",{parentName:"p"},'"@"')," character. Escaped ",(0,i.kt)("inlineCode",{parentName:"p"},'"@"')," characters are not placeholders, and so figures\ncannot be bound to the escaped ",(0,i.kt)("inlineCode",{parentName:"p"},"@"),". Template ",(0,i.kt)("inlineCode",{parentName:"p"},"@\\@@")," accepts exactly two figures. Binding any\nless or more then two figures results in ",(0,i.kt)("inlineCode",{parentName:"p"},"PlaceholderFigureException"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-php"},'$username = "mark";\n$mailPattern = Pattern::inject("@\\@\\w+.com", [$username]);\n')),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"Pattern")," in ",(0,i.kt)("inlineCode",{parentName:"p"},"$mail")," matches ",(0,i.kt)("inlineCode",{parentName:"p"},'"mark@gmail.com"'),", because the first occurrence of ",(0,i.kt)("inlineCode",{parentName:"p"},"@")," is a\nplaceholder, and so matches the bound string ",(0,i.kt)("inlineCode",{parentName:"p"},'"mark"'),", and the second character occurrence ",(0,i.kt)("inlineCode",{parentName:"p"},"@")," is\nescaped (",(0,i.kt)("inlineCode",{parentName:"p"},'"\\@"'),") and so is not a placeholder, thus matches ",(0,i.kt)("inlineCode",{parentName:"p"},'"@"')," literally."),(0,i.kt)("p",null,"Another possibility would be binding character ",(0,i.kt)("inlineCode",{parentName:"p"},'"@"')," as a figure, but that's not recommended."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-php"},'$username = "mark";\n$mailPattern = Pattern::inject("@@\\w+.com", [$username, \'@\']);\n')),(0,i.kt)("p",null,"Of course, binding ",(0,i.kt)("inlineCode",{parentName:"p"},'"@"')," string to the second placeholder does indeed match ",(0,i.kt)("inlineCode",{parentName:"p"},'"@"')," literally,\nbut that yields an insufficient expression. It's recommended to escape the ",(0,i.kt)("inlineCode",{parentName:"p"},"\\@")," character."),(0,i.kt)("h3",{id:"backslash-before-the-placeholder"},"Backslash before the placeholder"),(0,i.kt)("p",null,"To match characters ",(0,i.kt)("inlineCode",{parentName:"p"},'"\\@"')," literally, the backslash must be escaped, by regular expression.\nThe placeholder ",(0,i.kt)("inlineCode",{parentName:"p"},"@")," will be bound to the figure."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-php"},'$template = "\\\\\\\\@"; // string "\\\\@"\nPattern::inject($template, [$figure]);\n')),(0,i.kt)("p",null,"In simple terms: a backslash before a character (be it another backslash or a placeholder)\nrevokes its special meaning. Escaped backslash matches character ",(0,i.kt)("inlineCode",{parentName:"p"},'"\\"')," literally. Escaped\nplaceholder matches ",(0,i.kt)("inlineCode",{parentName:"p"},'"@"')," literally."),(0,i.kt)("p",null,"Remember about PHP string notation, when escaping special characters. In PHP, notation ",(0,i.kt)("inlineCode",{parentName:"p"},'"\\\\"')," is\nactually a single backslash, so in order to produce a string with two backslash characters, one\nshould choose PHP notation ",(0,i.kt)("inlineCode",{parentName:"p"},"'\\\\\\\\'")," or ",(0,i.kt)("inlineCode",{parentName:"p"},'"\\\\\\\\"'),", which produces a string of length ",(0,i.kt)("inlineCode",{parentName:"p"},"2"),", containing\ntwo backslashes."),(0,i.kt)("p",null,"Escaped ",(0,i.kt)("inlineCode",{parentName:"p"},'"@"')," character in PHP notation could be produced by ",(0,i.kt)("inlineCode",{parentName:"p"},'"\\\\@"')," (which yields ",(0,i.kt)("inlineCode",{parentName:"p"},'"\\@"'),"). For\nsimplicity, single quotes can be used which allow occasional backslash ",(0,i.kt)("inlineCode",{parentName:"p"},"'\\@'")," (which also yields ",(0,i.kt)("inlineCode",{parentName:"p"},'"\\@"'),")."),(0,i.kt)("p",null,"When in doubt, or struggling to get the amount of backslashes just right, inspecting the actual\ntemplate ",(0,i.kt)("inlineCode",{parentName:"p"},"string")," can be helpful, either by using debugger or by using ",(0,i.kt)("inlineCode",{parentName:"p"},"var_dump()"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'$template = "\\\\\\\\\\\\@";             // complex PHP notation\nvar_dump($template);               // inspect the template, it contains "\\\\\\@"\nPattern::inject($template, []); \n')),(0,i.kt)("p",null,"The inspection of ",(0,i.kt)("inlineCode",{parentName:"p"},"$template")," string variable revealed that PHP notation ",(0,i.kt)("inlineCode",{parentName:"p"},'$template = "\\\\\\\\\\\\@";'),"\nactually yields a string containing three backslashes ",(0,i.kt)("inlineCode",{parentName:"p"},'"\\"')," and one ",(0,i.kt)("inlineCode",{parentName:"p"},'"@"'),". So prepared patterns\ninterpret such template as one escaped backslash (",(0,i.kt)("inlineCode",{parentName:"p"},'"\\\\"'),") and one escaped ",(0,i.kt)("inlineCode",{parentName:"p"},'"\\@"'),", so such regular\nexpression matches string ",(0,i.kt)("inlineCode",{parentName:"p"},'"\\@"')," literally. "),(0,i.kt)("p",null,"A cleaner way of matching characters ",(0,i.kt)("inlineCode",{parentName:"p"},'"\\@"')," would be:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Pattern::literal('\\@')")," which matches ",(0,i.kt)("inlineCode",{parentName:"li"},'"\\@"')," literally"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Pattern::of('\\@')")," which also matches ",(0,i.kt)("inlineCode",{parentName:"li"},'"\\@"')),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Pattern::inject('@', ['\\@'])")," albeit template ",(0,i.kt)("inlineCode",{parentName:"li"},"'@'")," on itself is overly verbose")),(0,i.kt)("h2",{id:"quantified-placeholders"},"Quantified placeholders"),(0,i.kt)("p",null,"Placeholder ",(0,i.kt)("inlineCode",{parentName:"p"},"@")," used in template behaves very similarly to standard regular expression figures.\nIt is quantifiable, which means it can be followed by a quantifier. "),(0,i.kt)("p",null,"In standard regular expression, a quantifier determines the number of times the preceding figure is\nmatched. For example, ",(0,i.kt)("inlineCode",{parentName:"p"},"a+"),' means "match ',(0,i.kt)("inlineCode",{parentName:"p"},"a"),' one or more times". So regular expression ',(0,i.kt)("inlineCode",{parentName:"p"},"a+")," matches\nstrings: ",(0,i.kt)("inlineCode",{parentName:"p"},'"a"'),", ",(0,i.kt)("inlineCode",{parentName:"p"},'"aa"'),", ",(0,i.kt)("inlineCode",{parentName:"p"},'"aaa"'),", etc. Other quantifiers include ",(0,i.kt)("inlineCode",{parentName:"p"},"?")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"*"),'. The former indicates\nzero or one times, which is often called an "optional quantifier". Common examples of the optional\nquantifier include ',(0,i.kt)("inlineCode",{parentName:"p"},"https?://")," and ",(0,i.kt)("inlineCode",{parentName:"p"},".jpe?g"),", which match both ",(0,i.kt)("inlineCode",{parentName:"p"},'"http://"')," and ",(0,i.kt)("inlineCode",{parentName:"p"},'"https://"')," in the\nfirst example, and ",(0,i.kt)("inlineCode",{parentName:"p"},'".jpg"')," and ",(0,i.kt)("inlineCode",{parentName:"p"},'".jpeg"')," in the second example. The last quantifier wildcard is ",(0,i.kt)("inlineCode",{parentName:"p"},"*"),",\nwhich matches any number of times. Regular expression ",(0,i.kt)("inlineCode",{parentName:"p"},"\\(\\w*\\)")," matches any number of ",(0,i.kt)("inlineCode",{parentName:"p"},"\\w")," characters\nbetween parenthesis, for example: ",(0,i.kt)("inlineCode",{parentName:"p"},'"()"'),", ",(0,i.kt)("inlineCode",{parentName:"p"},'"(w)"'),", ",(0,i.kt)("inlineCode",{parentName:"p"},'"(wor)"'),", ",(0,i.kt)("inlineCode",{parentName:"p"},'"(words)"'),"."),(0,i.kt)("p",null,"Apart from the standard ",(0,i.kt)("inlineCode",{parentName:"p"},"?"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"+"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"*")," quantifiers, regular expressions also allow custom ranges,\nexpressed in regular expression ",(0,i.kt)("inlineCode",{parentName:"p"},"{n}"),",",(0,i.kt)("inlineCode",{parentName:"p"},"{n,}"),",",(0,i.kt)("inlineCode",{parentName:"p"},"{,n}"),",",(0,i.kt)("inlineCode",{parentName:"p"},"{n,n}"),". "),(0,i.kt)("p",null,"The corresponding quantifiers determine: "),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"{n}")," - exactly ",(0,i.kt)("inlineCode",{parentName:"li"},"n")," times"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"{n,}")," - ",(0,i.kt)("inlineCode",{parentName:"li"},"n")," or more times"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"{,n}")," - ",(0,i.kt)("inlineCode",{parentName:"li"},"n")," or less times"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"{n1,n2}")," - more than ",(0,i.kt)("inlineCode",{parentName:"li"},"n1")," times, but not more than ",(0,i.kt)("inlineCode",{parentName:"li"},"n2")," times.")),(0,i.kt)("p",null,"So in truth, quantifier ",(0,i.kt)("inlineCode",{parentName:"p"},"?")," is identical to ",(0,i.kt)("inlineCode",{parentName:"p"},"{,1}"),", quantifier ",(0,i.kt)("inlineCode",{parentName:"p"},"+")," is ",(0,i.kt)("inlineCode",{parentName:"p"},"{1,}")," and quantifier ",(0,i.kt)("inlineCode",{parentName:"p"},"*")," is\nidentical to ",(0,i.kt)("inlineCode",{parentName:"p"},"{0,}"),"."),(0,i.kt)("p",null,"Quantifiers ",(0,i.kt)("inlineCode",{parentName:"p"},"?"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"*"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"+")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"{1,2}")," can follow placeholder ",(0,i.kt)("inlineCode",{parentName:"p"},"@"),". The quantifier that follows the\nplaceholder, applies exclusively to the placeholder, and in the matching process, to the whole figure\nbound."),(0,i.kt)("h3",{id:"quantifier-"},"Quantifier ",(0,i.kt)("inlineCode",{parentName:"h3"},"?")),(0,i.kt)("p",null,"In the example below, the first placeholder is quantified with ",(0,i.kt)("inlineCode",{parentName:"p"},"?"),", and is bound a figure ",(0,i.kt)("inlineCode",{parentName:"p"},"'https'"),".\nThe second placeholder is not quantified."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-php"},"$uri = Pattern::inject('^@?://@$', ['https', 'google.com']);\n")),(0,i.kt)("p",null,"Pattern ",(0,i.kt)("inlineCode",{parentName:"p"},"$uri")," matches ",(0,i.kt)("inlineCode",{parentName:"p"},'"https://google.com"')," and ",(0,i.kt)("inlineCode",{parentName:"p"},'"://google.com"'),". However, it does not match\n",(0,i.kt)("inlineCode",{parentName:"p"},'"http://google.com"'),". The quantifier ",(0,i.kt)("inlineCode",{parentName:"p"},"?")," applies to the whole ",(0,i.kt)("inlineCode",{parentName:"p"},"'https'")," figure, so the quantified\nplaceholder ",(0,i.kt)("inlineCode",{parentName:"p"},"@?")," either matches the whole figure ",(0,i.kt)("inlineCode",{parentName:"p"},'"https"')," or nothing at all."),(0,i.kt)("h3",{id:"quantifier--1"},"Quantifier ",(0,i.kt)("inlineCode",{parentName:"h3"},"+")),(0,i.kt)("p",null,"In the the next example, the placeholder is quantified with ",(0,i.kt)("inlineCode",{parentName:"p"},"+"),", which means the figure matches\none or more times."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-php"},"$emptyParenthesis = Pattern::inject('@+', ['()']);\n")),(0,i.kt)("p",null,"Pattern ",(0,i.kt)("inlineCode",{parentName:"p"},"$emptyParenthesis")," matches strings: ",(0,i.kt)("inlineCode",{parentName:"p"},'"()"'),", ",(0,i.kt)("inlineCode",{parentName:"p"},'"()()"'),", ",(0,i.kt)("inlineCode",{parentName:"p"},'"()()()"'),", etc. but doesn't match ",(0,i.kt)("inlineCode",{parentName:"p"},'"()))"'),"."),(0,i.kt)("p",null,"It may appear, that since the bound figure ",(0,i.kt)("inlineCode",{parentName:"p"},'"()"')," consists of two characters, then perhaps\nthe ",(0,i.kt)("inlineCode",{parentName:"p"},"+")," quantifier applies only to the rightmost character, as in vanilla regular expression.\nThat is not the case with prepared patterns. The quantifier ",(0,i.kt)("inlineCode",{parentName:"p"},"+")," applies to the placeholder, and so\nfigure ",(0,i.kt)("inlineCode",{parentName:"p"},'"()"')," matches one or more times, but ",(0,i.kt)("inlineCode",{parentName:"p"},'")"')," is not matched on itself."),(0,i.kt)("p",null,"For curious readers, to match ",(0,i.kt)("inlineCode",{parentName:"p"},'"()"')," as well as ",(0,i.kt)("inlineCode",{parentName:"p"},'"()))"'),", one should use two placeholders and two\nfigures, for the prepared patterns to match ",(0,i.kt)("inlineCode",{parentName:"p"},'"("')," and ",(0,i.kt)("inlineCode",{parentName:"p"},'")"')," separately."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-php"},"$parenthesis = Pattern::inject('@@+', ['(', ')']);\n")),(0,i.kt)("p",null,"Pattern ",(0,i.kt)("inlineCode",{parentName:"p"},"$parenthesis")," matches ",(0,i.kt)("inlineCode",{parentName:"p"},'"()"')," as well as ",(0,i.kt)("inlineCode",{parentName:"p"},'"()))"'),". Entry-point ",(0,i.kt)("inlineCode",{parentName:"p"},"Pattern::of('\\(\\)+')")," can\nalso be used."),(0,i.kt)("h3",{id:"quantifier-after-an-empty-bound-figure"},"Quantifier after an empty bound figure"),(0,i.kt)("p",null,"In the final example with quantifiers, the placeholder is bound an empty string as a figure ",(0,i.kt)("inlineCode",{parentName:"p"},'""'),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-php"},"$emptyString = \"\";\n$pattern = Pattern::inject('^<@?>$', [$emptyString]);\n")),(0,i.kt)("p",null,"Pattern ",(0,i.kt)("inlineCode",{parentName:"p"},"$pattern")," matches subject ",(0,i.kt)("inlineCode",{parentName:"p"},'"<>"'),", but not ",(0,i.kt)("inlineCode",{parentName:"p"},'">"'),". It might appear, that since the figure\nis empty, the quantifier ",(0,i.kt)("inlineCode",{parentName:"p"},"?")," applies to the preceding character, in this case ",(0,i.kt)("inlineCode",{parentName:"p"},"<")," (as if the effective\nregular expression was ",(0,i.kt)("inlineCode",{parentName:"p"},"/<?>/"),"). That is not the case, the quantifier following the placeholder always\napplies to the bound figure, in this case an empty string."),(0,i.kt)("p",null,"In summary, given a template ",(0,i.kt)("inlineCode",{parentName:"p"},"^<@?>$"),": figure ",(0,i.kt)("inlineCode",{parentName:"p"},"<")," matches ",(0,i.kt)("inlineCode",{parentName:"p"},'"<"'),", quantified placeholder ",(0,i.kt)("inlineCode",{parentName:"p"},"@?")," matches\neither the bound figure or nothing (in which case it's either an empty string, or an empty string),\nand then finally ",(0,i.kt)("inlineCode",{parentName:"p"},">")," matches ",(0,i.kt)("inlineCode",{parentName:"p"},'">"'),". Granted, the pattern ",(0,i.kt)("inlineCode",{parentName:"p"},"$pattern")," doesn't serve much utility, but\nthe example given is only for illustrative purposes. Quantifiers apply to the placeholders - even\nwhen the bound figure itself is an empty string. "),(0,i.kt)("p",null,'In other words, the bound figure is matched as a single "chunk" and quantifiers and other regular\nexpression symbols used in the template don\'t "skip the chunk" (as shows the example with an empty\nfigure) and also don\'t  "split the chunk" (as shows the example with placeholder quantified with ',(0,i.kt)("inlineCode",{parentName:"p"},"+"),")."),(0,i.kt)("h2",{id:"capturing-placeholders"},"Capturing placeholders"),(0,i.kt)("p",null,"Placeholder ",(0,i.kt)("inlineCode",{parentName:"p"},"@")," used in template behaves very similarly to standard regular expression\nfigures, so can be captured when matched. Normally, placeholders don't capture anything."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-php"},"$pattern = Pattern::inject('^@?://@$', ['https', 'google.com']);\n")),(0,i.kt)("p",null,"Pattern ",(0,i.kt)("inlineCode",{parentName:"p"},"$pattern")," doesn't contain any capturing groups, so calling ",(0,i.kt)("inlineCode",{parentName:"p"},".get()")," or ",(0,i.kt)("inlineCode",{parentName:"p"},".group()"),"\non a matcher of such pattern would issue ",(0,i.kt)("inlineCode",{parentName:"p"},"NonexistentGroupException"),"."),(0,i.kt)("p",null,"However prepared patterns placeholders behave very similarly to standard regular expression\nfigures, and so can be captured just like any other regular expression figure."),(0,i.kt)("p",null,"To capture part of the template with placeholder ",(0,i.kt)("inlineCode",{parentName:"p"},"@"),", simply enclose the desired part with\na capturing group ",(0,i.kt)("inlineCode",{parentName:"p"},"()"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-php"},"// Instantiate the pattern\n$pattern = Pattern::inject('^(@?://)@$', ['https', 'google.com']);\n\n// match the pattern against the subject\n$matcher = $pattern->match('https://google.com');\n\n// match the first occurrence\n$detail = $matcher->first();\n$detail->get(1); // string \"https://\"\n")),(0,i.kt)("p",null,"To capture solely the placeholder, enclose the placeholder in the capturing group: ",(0,i.kt)("inlineCode",{parentName:"p"},"(@)"),". At first,\nit may appear that capturing only the placeholder serves very little value, since the captured text\nis going to be exactly the figure that was bound to the placeholder in the first place. While that\nis correct, not only text is captured in a capturing group, but also other data such as ",(0,i.kt)("inlineCode",{parentName:"p"},"Group.offset()"),"\nand ",(0,i.kt)("inlineCode",{parentName:"p"},"Group.tail()"),". Additionally, quantified capturing group ",(0,i.kt)("inlineCode",{parentName:"p"},"(@)?")," can determine whether the\nplaceholder was matched or not, using ",(0,i.kt)("inlineCode",{parentName:"p"},"Group.matched()"),"."),(0,i.kt)("h2",{id:"character--in-a-character-class"},"Character ",(0,i.kt)("inlineCode",{parentName:"h2"},"@")," in a character class"),(0,i.kt)("p",null,"Most standard regular expression symbols, when used in a character class, are revoked its special\nregular expression meaning. Such symbols are then matched literally."),(0,i.kt)("p",null,"For example, special character period ",(0,i.kt)("inlineCode",{parentName:"p"},".")," and special character ",(0,i.kt)("inlineCode",{parentName:"p"},"?"),' used in a character class\nare no longer interpreted as "any character" (for the period ',(0,i.kt)("inlineCode",{parentName:"p"},"."),") and as optional quantifier (for\nthe question mark ",(0,i.kt)("inlineCode",{parentName:"p"},"?"),"). Instead, they're matched literally."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-php"},"$dotsAndQuestions = Pattern::of('^[.?]$');\n")),(0,i.kt)("p",null,"Pattern ",(0,i.kt)("inlineCode",{parentName:"p"},"$dotsAndQuestions")," matches string ",(0,i.kt)("inlineCode",{parentName:"p"},'"."')," or ",(0,i.kt)("inlineCode",{parentName:"p"},'"?"'),"."),(0,i.kt)("p",null,"The same is true for character ",(0,i.kt)("inlineCode",{parentName:"p"},"@")," used in a character class."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-php"},"$pattern = Pattern::inject('^[.?@]$', []);\n")),(0,i.kt)("p",null,"Character ",(0,i.kt)("inlineCode",{parentName:"p"},"@")," present in a character class in prepared patterns is not a placeholder, and so\na figure cannot be bound to it. Pattern ",(0,i.kt)("inlineCode",{parentName:"p"},"$pattern")," matches ",(0,i.kt)("inlineCode",{parentName:"p"},'"@"')," as well as ",(0,i.kt)("inlineCode",{parentName:"p"},'"."')," and ",(0,i.kt)("inlineCode",{parentName:"p"},'"?"'),". Binding a figure\nto a template in which character ",(0,i.kt)("inlineCode",{parentName:"p"},"@")," is in a character class (and in which there are no other placeholders)\nthrows ",(0,i.kt)("inlineCode",{parentName:"p"},"PlaceholderFigureException"),", since the number of placeholders in the template and the number\nof bound figures must match, and character ",(0,i.kt)("inlineCode",{parentName:"p"},"@")," in a character class is not a placeholder."),(0,i.kt)("p",null,"Escaped ",(0,i.kt)("inlineCode",{parentName:"p"},"@")," character in the character class behaves similarly to other escaped character in the character class,\nand by regular expression escapes of characters ",(0,i.kt)("inlineCode",{parentName:"p"},"."),", ",(0,i.kt)("inlineCode",{parentName:"p"},"?")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"@")," are redundant. More precisely, there is\nno difference between escaped ",(0,i.kt)("inlineCode",{parentName:"p"},".")," and non-escaped period in the character class. That's also true for ",(0,i.kt)("inlineCode",{parentName:"p"},"?"),"\nand of course character ",(0,i.kt)("inlineCode",{parentName:"p"},"@")," in the character class."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-php"},"$pattern = Pattern::inject('^[\\.\\?\\@]$', []);\n")),(0,i.kt)("p",null,"Pattern ",(0,i.kt)("inlineCode",{parentName:"p"},"$pattern")," matches the same subjects: ",(0,i.kt)("inlineCode",{parentName:"p"},'"."'),", ",(0,i.kt)("inlineCode",{parentName:"p"},'"?"')," and ",(0,i.kt)("inlineCode",{parentName:"p"},'"@"'),"."),(0,i.kt)("h2",{id:"comments"},"Comments"),(0,i.kt)("p",null,"Regular expressions offer notation for comments within the expression. The two kinds of comments in prepared\npatterns are: group comments and extended comment (when ",(0,i.kt)("inlineCode",{parentName:"p"},"/x")," modifier is set). The comments don't match any\ncharacters, cannot be quantified, nested in other comments or otherwise referred to by other regular expression\nconstructs. "),(0,i.kt)("p",null,'As a figure of speech, one can say that comments are "ignored" by the regular expressions. That is not entirely\ntrue, since the comment groups and extended comments still must be parsed and interpreted by the regular\nexpression engine, however it can be said that the comments are ignored in the matching process.'),(0,i.kt)("h3",{id:"group-comments"},"Group comments"),(0,i.kt)("p",null,"Syntax for group comment in regular expression is ",(0,i.kt)("inlineCode",{parentName:"p"},"(?#...)"),". Any characters enclosed in a group comment\naren't matched or interpreted as regular expression special characters in any way. In particular, backslash\n",(0,i.kt)("inlineCode",{parentName:"p"},"\\ "),"  in the comment group is interpreted as comment, and so doesn't escape anything. The closing parenthesis\nterminates the comment group."),(0,i.kt)("p",null,"When character ",(0,i.kt)("inlineCode",{parentName:"p"},"@")," appears in the group comment, it is also interpreted as comment by prepared patterns,\nand as such is not considered a placeholder."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-php"},"$pattern = Pattern::inject('^word(?#mail@gmail.com)$', []);\n")),(0,i.kt)("p",null,"Pattern ",(0,i.kt)("inlineCode",{parentName:"p"},"$pattern")," matches subject ",(0,i.kt)("inlineCode",{parentName:"p"},'"word"'),". No figure can be bound to the template. The template doesn't\ncontain any placeholders, since character ",(0,i.kt)("inlineCode",{parentName:"p"},"@")," in the template is enclosed in the comment group."),(0,i.kt)("h3",{id:"comments-and-x-modifier"},"Comments and ",(0,i.kt)("inlineCode",{parentName:"h3"},"/x")," modifier"),(0,i.kt)("p",null,"Apart from standard regular expression group comment, PCRE offers extended syntax for regular expressions."),(0,i.kt)("p",null,"Extended syntax in regular expressions can be enabled by setting ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," (lowercase) modifier in the pattern.\nIn extended mode, whitespace is not being matched and additional comment notation is available. Comments\nstart with character ",(0,i.kt)("inlineCode",{parentName:"p"},"#")," and end with with the current newline character. "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-php"},"$pattern = Pattern::of('\n    https?://     # scheme\n    (?:www\\.)?    # optional www.\n    [a-z0-9-]+    # the domain\n    \\.(org|com)   # top-level domain\n', 'x');\n")),(0,i.kt)("p",null,"Pattern ",(0,i.kt)("inlineCode",{parentName:"p"},"$pattern")," from the example above is actually identical to the pattern without ",(0,i.kt)("inlineCode",{parentName:"p"},"/x")," modifier set:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-php"},"$pattern = Pattern::of('https?://(?:www\\.)?[a-z0-9-]+\\.(org|com)');\n")),(0,i.kt)("p",null,"In extended mode, leading and trailing whitespace as well as comments can be added for readability and\nfor spacial padding, to ease the understanding of the regular expression. Not every whitespace is ignored,\nof course, for example, escaped spaces ",(0,i.kt)("inlineCode",{parentName:"p"},'"\\ "')," still match a space ",(0,i.kt)("inlineCode",{parentName:"p"},'" "'),", and so do spaces in character classes."),(0,i.kt)("p",null,"When character ",(0,i.kt)("inlineCode",{parentName:"p"},"@")," is used in a comment, it is treated as part of the comment."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-php"},"$mailPattern = Pattern::inject('\n    ^                    # start\n    @                    # username\n    \\@                   # at \"@\" character\n    (gmail|hotmail)\\.com # domain\n    $                    # end\n', [$username], 'x');\n")),(0,i.kt)("p",null,"The first character ",(0,i.kt)("inlineCode",{parentName:"p"},"@")," is a placeholder with bound username, the second character ",(0,i.kt)("inlineCode",{parentName:"p"},"@")," is escaped\nin the regular expression, and the third is part of the comment, and as such is not a placeholder."),(0,i.kt)("h2",{id:"quote-with-q-and-e"},"Quote with ",(0,i.kt)("inlineCode",{parentName:"h2"},"\\Q")," and ",(0,i.kt)("inlineCode",{parentName:"h2"},"\\E")),(0,i.kt)("p",null,"By regular expression, characters enclosed between ",(0,i.kt)("inlineCode",{parentName:"p"},"\\Q")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"\\E")," are matched literally. No special\ncharacter maintains its special behaviour. In particular, backslash character is matched literally,\nthus no escaping happens within ",(0,i.kt)("inlineCode",{parentName:"p"},"\\Q")," ",(0,i.kt)("inlineCode",{parentName:"p"},"\\E")," quote. For example, ",(0,i.kt)("inlineCode",{parentName:"p"},"\\Q\\\\E")," matches backslash ",(0,i.kt)("inlineCode",{parentName:"p"},'"\\"')," literally.\nFigure ",(0,i.kt)("inlineCode",{parentName:"p"},"\\E")," that's not preceded by a corresponding ",(0,i.kt)("inlineCode",{parentName:"p"},"\\Q"),", is simply ignored. On the other hand, ",(0,i.kt)("inlineCode",{parentName:"p"},"\\Q"),"\nwithout the corresponding ",(0,i.kt)("inlineCode",{parentName:"p"},"\\E")," continues the literal quote to the end of the expression - the missing\n",(0,i.kt)("inlineCode",{parentName:"p"},"\\E")," is assumed to be present at the end of the pattern."),(0,i.kt)("p",null,"Additionally, ",(0,i.kt)("inlineCode",{parentName:"p"},"\\Q")," ",(0,i.kt)("inlineCode",{parentName:"p"},"\\E")," quote can also appear in its entirety in a character class, for example:\n",(0,i.kt)("inlineCode",{parentName:"p"},"[\\Q]\\\\E]"),". Such character class matches characters ",(0,i.kt)("inlineCode",{parentName:"p"},'"]"')," and ",(0,i.kt)("inlineCode",{parentName:"p"},'"\\"'),". "),(0,i.kt)("p",null,"Pair ",(0,i.kt)("inlineCode",{parentName:"p"},"\\Q")," ",(0,i.kt)("inlineCode",{parentName:"p"},"\\E")," can be used to match a sequence of characters, which are supposed to be treated literally,\nwithout losing much readability. A common use-case would be a regular expression, that's supposed\nto match ",(0,i.kt)("em",{parentName:"p"},"other")," regular expressions. Should we match string ",(0,i.kt)("inlineCode",{parentName:"p"},'"^https?://(\\w+@)?[\\w.]+/"'),", quote in\n",(0,i.kt)("inlineCode",{parentName:"p"},"\\Q")," ",(0,i.kt)("inlineCode",{parentName:"p"},"\\E")," could be viable choice for that. Of course, it doesn't differ much from escaping all the\nspecial characters in terms of matching - it gains only in readability."),(0,i.kt)("p",null,"Character ",(0,i.kt)("inlineCode",{parentName:"p"},"@")," appearing within ",(0,i.kt)("inlineCode",{parentName:"p"},"\\Q")," ",(0,i.kt)("inlineCode",{parentName:"p"},"\\E")," quote is not a placeholder, and thus is matched literally.\nQuote ",(0,i.kt)("inlineCode",{parentName:"p"},"\\Q")," ",(0,i.kt)("inlineCode",{parentName:"p"},"\\E")," matches every character within it, and so character ",(0,i.kt)("inlineCode",{parentName:"p"},"@")," is also matched literally,\nshould ",(0,i.kt)("inlineCode",{parentName:"p"},"\\Q")," be used."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-php"},"$pattern = Pattern::inject('^(\\Q^https?://(\\w+@)?[\\w.]+/\\E)+$', []);\n")),(0,i.kt)("p",null,"Notice, however, that even more readability can be gained by binding the exact string to the placeholder."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-php"},"$pattern = Pattern::inject('^(\\Q^https?://(\\w+@)?[\\w.]+/\\E)+$', []);\n$pattern = Pattern::inject('^@+$', ['^https?://(\\w+@)?[\\w.]+/']);\n")),(0,i.kt)("p",null,"On the point of secure regular expression, it might appear that because all characters are matched\nliterally within ",(0,i.kt)("inlineCode",{parentName:"p"},"\\Q")," ",(0,i.kt)("inlineCode",{parentName:"p"},"\\E"),", it could be safe to use PHP string interpolation to insert parts of the\nvalues to be matched."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-php"},'$value = "...";                               // values to be matched literally\n$pattern = Pattern::of("^(\\Q$values\\E)+$");   // potentially dangerous\n')),(0,i.kt)("p",null,"However, that may not be the best way to incorporate such values into the pattern, since ",(0,i.kt)("inlineCode",{parentName:"p"},"$value")," can\npotentially contain ",(0,i.kt)("inlineCode",{parentName:"p"},"\\E"),", in which case the characters following ",(0,i.kt)("inlineCode",{parentName:"p"},"\\E")," in ",(0,i.kt)("inlineCode",{parentName:"p"},"$value")," will be interpreted\nwith their respective special regular expression behaviour. "),(0,i.kt)("p",null,"It's recommended to bind the value to the placeholder:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-php"},'$value = "..."; // values to be matched literally\n$pattern = Pattern::inject("^@+$", [$value]);\n')),(0,i.kt)("p",null,"Additionally, placeholders are quantifiable, where-as quotes ",(0,i.kt)("inlineCode",{parentName:"p"},"\\Q")," ",(0,i.kt)("inlineCode",{parentName:"p"},"\\E")," are not (",(0,i.kt)("inlineCode",{parentName:"p"},"\\Q\\E+")," is a pattern error). "),(0,i.kt)("p",null,"For these facts, quote ",(0,i.kt)("inlineCode",{parentName:"p"},"\\Q")," ",(0,i.kt)("inlineCode",{parentName:"p"},"\\E")," is used very rarely, and placeholders with bound figures are used much more\nfrequently."),(0,i.kt)("h2",{id:"improper-usage-of--placeholder"},"Improper usage of ",(0,i.kt)("inlineCode",{parentName:"h2"},"@")," placeholder"),(0,i.kt)("p",null,"Some syntax constructs in the prepared patterns aren't applicable to be used with ",(0,i.kt)("inlineCode",{parentName:"p"},"@")," placeholders. One\nsuch construct is named capturing groups. Character ",(0,i.kt)("inlineCode",{parentName:"p"},"@")," used in the name of a capturing group: ",(0,i.kt)("inlineCode",{parentName:"p"},"(?<@gmail>)"),",\nis not a placeholder, and so figure is not bound to it. Furthermore, such template yields a pattern which\nalso contains ",(0,i.kt)("inlineCode",{parentName:"p"},"(?<@gmail>)"),", which isn't a properly formatted regular expression. And as any improperly\nformed regular expression pattern, it throws ",(0,i.kt)("inlineCode",{parentName:"p"},"MalformedPatternException")," when used."),(0,i.kt)("h2",{id:"summary"},"Summary"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Placeholders ",(0,i.kt)("inlineCode",{parentName:"li"},"@")," behave similarly to standard regular expression figures"),(0,i.kt)("li",{parentName:"ul"},"Placeholders ",(0,i.kt)("inlineCode",{parentName:"li"},"@")," don't capture, but can be enclosed in a capturing group"),(0,i.kt)("li",{parentName:"ul"},"Placeholders ",(0,i.kt)("inlineCode",{parentName:"li"},"@")," can be quantified with ",(0,i.kt)("inlineCode",{parentName:"li"},"?"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"+"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"*")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"{2,3}")),(0,i.kt)("li",{parentName:"ul"},"Empty strings can be safely bound to quantified placeholders"),(0,i.kt)("li",{parentName:"ul"},"Escaped placeholders ",(0,i.kt)("inlineCode",{parentName:"li"},"\\@")," match ",(0,i.kt)("inlineCode",{parentName:"li"},'"@"')," literally"),(0,i.kt)("li",{parentName:"ul"},"Character ",(0,i.kt)("inlineCode",{parentName:"li"},"@")," in a character class matches ",(0,i.kt)("inlineCode",{parentName:"li"},'"@"')," literally"),(0,i.kt)("li",{parentName:"ul"},"Character ",(0,i.kt)("inlineCode",{parentName:"li"},"@")," in a group comment is not a placeholder"),(0,i.kt)("li",{parentName:"ul"},"Character ",(0,i.kt)("inlineCode",{parentName:"li"},"@")," in an extended mode comment is not a placeholder"),(0,i.kt)("li",{parentName:"ul"},"Character ",(0,i.kt)("inlineCode",{parentName:"li"},"@")," in quote between ",(0,i.kt)("inlineCode",{parentName:"li"},"\\Q")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"\\E")," matches ",(0,i.kt)("inlineCode",{parentName:"li"},"@")," literally"),(0,i.kt)("li",{parentName:"ul"},"Character ",(0,i.kt)("inlineCode",{parentName:"li"},"@")," used as a group name is not a valid template and throws ",(0,i.kt)("inlineCode",{parentName:"li"},"MalformedPatternException"))))}c.isMDXComponent=!0}}]);