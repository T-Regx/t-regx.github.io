"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[4508],{3905:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>k});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function p(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var o=a.createContext({}),s=function(e){var t=a.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):p(p({},t),e)),n},m=function(e){var t=s(e.components);return a.createElement(o.Provider,{value:t},e.children)},d="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,o=e.parentName,m=l(e,["components","mdxType","originalType","parentName"]),d=s(n),u=r,k=d["".concat(o,".").concat(u)]||d[u]||c[u]||i;return n?a.createElement(k,p(p({ref:t},m),{},{components:n})):a.createElement(k,p({ref:t},m))}));function k(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,p=new Array(i);p[0]=u;var l={};for(var o in t)hasOwnProperty.call(t,o)&&(l[o]=t[o]);l.originalType=e,l[d]="string"==typeof e?e:r,p[1]=l;for(var s=2;s<i;s++)p[s]=n[s];return a.createElement.apply(null,p)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},6573:(e,t,n)=>{n.r(t),n.d(t,{default:()=>c,frontMatter:()=>l,metadata:()=>o,toc:()=>s});var a=n(7462),r=n(3366),i=(n(7294),n(3905)),p=["components"],l={id:"prepared-patterns",title:"Prepared Patterns - Introduction",sidebar_label:"Introduction"},o={unversionedId:"prepared-patterns",id:"prepared-patterns",isDocsHomePage:!1,title:"Prepared Patterns - Introduction",description:"Documentation for version: 0.41.2",source:"@site/../docs/prepared-patterns.md",sourceDirName:".",slug:"/prepared-patterns",permalink:"/docs/prepared-patterns",version:"current",lastUpdatedAt:1675613365,formattedLastUpdatedAt:"2/5/2023",sidebar_label:"Introduction",frontMatter:{id:"prepared-patterns",title:"Prepared Patterns - Introduction",sidebar_label:"Introduction"},sidebar:"docs",previous:{title:"Replace with callback",permalink:"/docs/replace-callback"},next:{title:"Template Syntax",permalink:"/docs/template-syntax"}},s=[{value:"Introduction",id:"introduction",children:[{value:"Regular expression template",id:"regular-expression-template",children:[]},{value:"Conditional placeholders",id:"conditional-placeholders",children:[]}]},{value:"Pre-compiling templates",id:"pre-compiling-templates",children:[{value:"Pre-compiling templates with multiple figures",id:"pre-compiling-templates-with-multiple-figures",children:[]}]},{value:"PCRE-styled patterns",id:"pcre-styled-patterns",children:[]},{value:"Frequently asked questions",id:"frequently-asked-questions",children:[]},{value:"What about special cases",id:"what-about-special-cases",children:[]},{value:"Terminology",id:"terminology",children:[]}],m={toc:s},d="wrapper";function c(e){var t=e.components,n=(0,r.Z)(e,p);return(0,i.kt)(d,(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Documentation for version: 0.41.2"),(0,i.kt)("p",null,"When arbitrary value is needed in the pattern, it might be tempting to use simple string concatenation.\nHowever, integration of dynamic values such as ",(0,i.kt)("inlineCode",{parentName:"p"},"$_GET['domain']")," can be troublesome or even dangerous."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-php"},"Pattern::of('^https://' . $_GET['domain'] . '\\.(com|net)');  // risky and dangerous\n")),(0,i.kt)("p",null,"But you, dear reader, know that's a terrible, terrible idea. ",(0,i.kt)("inlineCode",{parentName:"p"},"$_GET['domain']")," may contain\nunexpected/malicious regular expression special characters, which at best will match incorrect\ncharacters, malform the pattern completely, or in the worse case - open the door to ReDos attack."),(0,i.kt)("p",null,"Potential risks include:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Complex look-aheads and look-arounds (",(0,i.kt)("inlineCode",{parentName:"li"},"(?!<"),")"),(0,i.kt)("li",{parentName:"ul"},"Recursive patterns (",(0,i.kt)("inlineCode",{parentName:"li"},"(?R)"),")"),(0,i.kt)("li",{parentName:"ul"},"Structures prone to catastrophic backtracking")),(0,i.kt)("h2",{id:"introduction"},"Introduction"),(0,i.kt)("p",null,"Prepared patterns is T-Regx solution for using arbitrary, dynamic values that need to be\nintegrated into the regular expression. ",(0,i.kt)("inlineCode",{parentName:"p"},"Pattern")," instantiated with prepared patterns\nare safely constructed. Such construction alleviates the dangers of ReDos attacks and\nimproper regular expression syntax."),(0,i.kt)("p",null,"The idea is very similar to prepared statements from SQL world, in which many SQL statements\nsuffer from a very similar issue, yet in that case the trouble is either improper SQL syntax\nor even SQL-Injection vulnerability. Despite being utterly different technologies, both ReDos\nand SQL-Injection vulnerabilities come from the same error - improper integration of language\n(Regexp and SQL) and arbitrary parameters passed into it."),(0,i.kt)("h3",{id:"regular-expression-template"},"Regular expression template"),(0,i.kt)("p",null,"In order to safely integrate dynamic or unsafe values into the regular expression, special\ncharacter ",(0,i.kt)("inlineCode",{parentName:"p"},"@")," must be used in the expression as a ",(0,i.kt)("em",{parentName:"p"},"placeholder"),". The ",(0,i.kt)("inlineCode",{parentName:"p"},"@")," placeholder behaves\nlike a standard regular expression figure, and matches whatever characters or figures are\nbound to it when prepared pattern is instantiated."),(0,i.kt)("p",null,"The placeholder ",(0,i.kt)("inlineCode",{parentName:"p"},"@")," matches a literal value (",(0,i.kt)("inlineCode",{parentName:"p"},"string"),"), an alteration of values or more\ncomplex structures, such as other patterns or masks, depending on what ",(0,i.kt)("em",{parentName:"p"},"figure")," exactly was\nbound to the particular ",(0,i.kt)("em",{parentName:"p"},"placeholder"),". First, let's take a look at literal values."),(0,i.kt)("p",null,"Looking at the previous example, the initial regular expression is improperly constructed by\nstring concatenation."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-php"},"$input = $_GET['name'];\n\nPattern::of(\"(My|Our) dog's name is \" . $input . '!');  // improper and risky\n")),(0,i.kt)("p",null,"Naive string concatenation is risky for various reasons. Let us use ",(0,i.kt)("inlineCode",{parentName:"p"},"Pattern::inject()"),", instead."),(0,i.kt)("p",null,"Instead of concatenating with ",(0,i.kt)("inlineCode",{parentName:"p"},"$input"),", let's add ",(0,i.kt)("em",{parentName:"p"},"placeholder")," ",(0,i.kt)("inlineCode",{parentName:"p"},"@")," into the regular expression,\nand bind ",(0,i.kt)("inlineCode",{parentName:"p"},"$input")," ",(0,i.kt)("em",{parentName:"p"},"figure")," to it. The placeholder ",(0,i.kt)("inlineCode",{parentName:"p"},"@")," used in the regular expression will match\nwhatever characters or figures are bound to it. With ",(0,i.kt)("inlineCode",{parentName:"p"},"Pattern::inject()"),", the bound values\n(called ",(0,i.kt)("em",{parentName:"p"},"figures"),") are supposed to be passed as an ",(0,i.kt)("inlineCode",{parentName:"p"},"array"),", as the second argument of ",(0,i.kt)("inlineCode",{parentName:"p"},"Pattern::inject()"),"."),(0,i.kt)("p",null,"In T-Regx terminology, a ",(0,i.kt)("em",{parentName:"p"},"figure")," is whatever is being matched by ",(0,i.kt)("em",{parentName:"p"},"placeholder")," ",(0,i.kt)("inlineCode",{parentName:"p"},"@"),". Scroll down,\nto read more about ",(0,i.kt)("a",{parentName:"p",href:"#terminology"},"Terminology"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-php"},"$input = $_GET['name'];\n\n$pattern = Pattern::inject(\"(My|Our) dog's name is @!\", [$input]);\n")),(0,i.kt)("p",null,"Using regular expressions with ",(0,i.kt)("inlineCode",{parentName:"p"},"@")," placeholder and binding figures to it is the recommended\napproach, instead of naive string concatenation."),(0,i.kt)("p",null,"Entry point ",(0,i.kt)("inlineCode",{parentName:"p"},"Pattern::inject()")," returns an instance of ",(0,i.kt)("inlineCode",{parentName:"p"},"Pattern"),", exactly like ",(0,i.kt)("inlineCode",{parentName:"p"},"Pattern::of()"),",\nso the interface of the ",(0,i.kt)("inlineCode",{parentName:"p"},"Pattern")," is exactly the same."),(0,i.kt)("p",null,"Following the example above: ",(0,i.kt)("inlineCode",{parentName:"p"},'Pattern::inject("(My|Our) dog\'s name is @!", [$input])'),", we find\nthat the ",(0,i.kt)("inlineCode",{parentName:"p"},"Pattern")," will match: one of ",(0,i.kt)("inlineCode",{parentName:"p"},'"My"')," or ",(0,i.kt)("inlineCode",{parentName:"p"},'"Our"'),", then string ",(0,i.kt)("inlineCode",{parentName:"p"},'" dog\'s name is "')," literally,\nthen whatever was passed in ",(0,i.kt)("inlineCode",{parentName:"p"},"$_GET['name']"),", and then ",(0,i.kt)("inlineCode",{parentName:"p"},'"!"')," literally. Any regular expression\ncharacters, such as ",(0,i.kt)("inlineCode",{parentName:"p"},"."),", ",(0,i.kt)("inlineCode",{parentName:"p"},"?"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"("),", ",(0,i.kt)("inlineCode",{parentName:"p"},")")," that are potentially present in ",(0,i.kt)("inlineCode",{parentName:"p"},"$_GET['name']")," will be\nmatched literally, not as a regular expression. This is the main reason why Prepared Patterns\nalleviate risks of malformed patterns and ReDos attacks."),(0,i.kt)("p",null,"Should two values be required in the pattern - a ",(0,i.kt)("em",{parentName:"p"},"template")," with two ",(0,i.kt)("inlineCode",{parentName:"p"},"@")," placeholders must be\nused, and two ",(0,i.kt)("em",{parentName:"p"},"figures")," must be passed as the second argument."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-php"},"$start = $_GET['start'];\n$end = $_GET['end'];\n\n$pattern = Pattern::inject(\"^@:\\w+?:@$\", [$start, $end]);\n")),(0,i.kt)("p",null,"The number of ",(0,i.kt)("inlineCode",{parentName:"p"},"@")," ",(0,i.kt)("em",{parentName:"p"},"placeholders")," in the ",(0,i.kt)("em",{parentName:"p"},"template")," and the number of ",(0,i.kt)("em",{parentName:"p"},"figures")," bound must be\nequal. When too many or too little ",(0,i.kt)("em",{parentName:"p"},"figures")," is bound to the ",(0,i.kt)("em",{parentName:"p"},"template"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"PlaceholderFigureException"),"\nis thrown and instantiation of ",(0,i.kt)("inlineCode",{parentName:"p"},"Pattern")," fails."),(0,i.kt)("p",null,"Close examination of the constructed ",(0,i.kt)("inlineCode",{parentName:"p"},"Pattern")," can be done by casting the resulting ",(0,i.kt)("inlineCode",{parentName:"p"},"Pattern"),"\nto ",(0,i.kt)("inlineCode",{parentName:"p"},"string"),". Casting any instance of ",(0,i.kt)("inlineCode",{parentName:"p"},"Pattern"),", regardless of whether it was created with ",(0,i.kt)("inlineCode",{parentName:"p"},"Pattern::of()"),",\n",(0,i.kt)("inlineCode",{parentName:"p"},"Pattern::inject()")," or any other entry point, results in a delimited regular expression."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-php"},'/* Pass a potentially unsafe string */\n$input = "w.w?";\n\n/* Safely instantiate the pattern */\n$pattern = Pattern::inject("^\'@!+$", [$input]);\n\n/* Examine the constructed regular expression */\n$regularExpression = (string) $pattern;\n\n/* Render the regular expression, for debugging purposes */\necho $regularExpression;\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"/^'w\\.w\\?!+$/\n")),(0,i.kt)("p",null,"When examining the constructed regular expression from ",(0,i.kt)("inlineCode",{parentName:"p"},"Pattern"),", you will notice that special\ncharacters ",(0,i.kt)("inlineCode",{parentName:"p"},".")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"?")," used in ",(0,i.kt)("inlineCode",{parentName:"p"},'"w.w?"')," are represented as escaped characters ",(0,i.kt)("inlineCode",{parentName:"p"},"\\.")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"\\?")," in\nthe regular expression."),(0,i.kt)("p",null,"More details on placeholder ",(0,i.kt)("inlineCode",{parentName:"p"},"@")," syntax can be found in the next chapter: ",(0,i.kt)("a",{parentName:"p",href:"/docs/template-syntax"},"Template Syntax"),".\nAlso, scroll to ",(0,i.kt)("a",{parentName:"p",href:"#frequently-asked-questions"},"FAQ")," for the most common questions."),(0,i.kt)("h3",{id:"conditional-placeholders"},"Conditional placeholders"),(0,i.kt)("p",null,"Placeholder ",(0,i.kt)("inlineCode",{parentName:"p"},"@")," in ",(0,i.kt)("em",{parentName:"p"},"template")," behaves like all other regular expression figures, so expression\n",(0,i.kt)("inlineCode",{parentName:"p"},"@?")," is an optional placeholder, which matches an optional bound figure. Of course, other\nquantifiers such as ",(0,i.kt)("inlineCode",{parentName:"p"},"*")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"+")," are also allowed, for example ",(0,i.kt)("inlineCode",{parentName:"p"},"@*")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"@+"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-php"},'$directory = "home_folder";\n$filename = "image.jpg";\n\n$directoryPattern = Pattern::inject("^/@/@?$", [$directory, $filename]);\n')),(0,i.kt)("p",null,"Notice, that the second placeholder ",(0,i.kt)("inlineCode",{parentName:"p"},"@?")," matches optionally, due to it being followed by the\nwildcard ",(0,i.kt)("inlineCode",{parentName:"p"},"?"),", by regular expression. Because of that, ",(0,i.kt)("inlineCode",{parentName:"p"},"$directoryPattern")," will match either\n",(0,i.kt)("inlineCode",{parentName:"p"},'"/home_folder/"')," or ",(0,i.kt)("inlineCode",{parentName:"p"},'"/home_folder/image.jpg"'),". Note for curious readers - it will not match\n",(0,i.kt)("inlineCode",{parentName:"p"},'"/home_folder/image.jp"'),"."),(0,i.kt)("p",null,"By regular expression, ",(0,i.kt)("inlineCode",{parentName:"p"},"@?")," matches the figures greedily. Analyzing the ",(0,i.kt)("em",{parentName:"p"},"template"),", we see:\nassertion ",(0,i.kt)("inlineCode",{parentName:"p"},"^")," matches the start of the subject, ",(0,i.kt)("inlineCode",{parentName:"p"},"/")," matches character ",(0,i.kt)("inlineCode",{parentName:"p"},'"/"')," literally,\nthe first placeholder ",(0,i.kt)("inlineCode",{parentName:"p"},"@")," matches ",(0,i.kt)("em",{parentName:"p"},"figure")," ",(0,i.kt)("inlineCode",{parentName:"p"},'"home_folder"'),", then ",(0,i.kt)("inlineCode",{parentName:"p"},"/")," matches ",(0,i.kt)("inlineCode",{parentName:"p"},'"/"'),", then\nthe second placeholder ",(0,i.kt)("inlineCode",{parentName:"p"},"@")," matches ",(0,i.kt)("inlineCode",{parentName:"p"},'"image.jpg"')," literally, greedy quantifier ",(0,i.kt)("inlineCode",{parentName:"p"},"?")," means the\nprevious token (which is ",(0,i.kt)("inlineCode",{parentName:"p"},"@"),") matches 0 or 1 time, as much as possible, which means ",(0,i.kt)("inlineCode",{parentName:"p"},"@?"),"\nmatches either ",(0,i.kt)("inlineCode",{parentName:"p"},'"image.jpg"')," or nothing at all; and finally assertion ",(0,i.kt)("inlineCode",{parentName:"p"},"$")," matches the end of\nsubject."),(0,i.kt)("p",null,"To conditionally match a placeholder, but not greedily, the placeholder should be followed\nby ",(0,i.kt)("inlineCode",{parentName:"p"},"??"),", by regular expression."),(0,i.kt)("p",null,"It's worth to mention, that regardless of the quantifier used for the ",(0,i.kt)("em",{parentName:"p"},"placeholder"),", the figure\nmust still be bound for the placeholder. Omitting the figure in the ",(0,i.kt)("inlineCode",{parentName:"p"},"Pattern::inject()"),", while\na valid ",(0,i.kt)("inlineCode",{parentName:"p"},"@")," placeholder is used in the ",(0,i.kt)("em",{parentName:"p"},"template"),", even followed by ",(0,i.kt)("inlineCode",{parentName:"p"},"?"),", is disallowed."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-php"},'Pattern::inject("^/@/@?$", [$directory]);  // throws PlaceholderFigureException\n')),(0,i.kt)("p",null,"In other words, ",(0,i.kt)("em",{parentName:"p"},"template")," ",(0,i.kt)("inlineCode",{parentName:"p"},"^/@/@?$")," consists of two placeholders, and thus two bound ",(0,i.kt)("em",{parentName:"p"},"figures"),"\nare required."),(0,i.kt)("p",null,"More details on usage of ",(0,i.kt)("inlineCode",{parentName:"p"},"@")," ",(0,i.kt)("em",{parentName:"p"},"placeholder")," in the ",(0,i.kt)("em",{parentName:"p"},"template")," be found in the next chapter:\n",(0,i.kt)("a",{parentName:"p",href:"/docs/template-syntax"},"Template Syntax"),". Also, scroll to ",(0,i.kt)("a",{parentName:"p",href:"#frequently-asked-questions"},"FAQ")," for\nthe most common questions."),(0,i.kt)("h2",{id:"pre-compiling-templates"},"Pre-compiling templates"),(0,i.kt)("p",null,"A quite popular use-case of prepared patterns appears when a single ",(0,i.kt)("em",{parentName:"p"},"template")," should be used\nto instantiate multiple instances of ",(0,i.kt)("inlineCode",{parentName:"p"},"Pattern")," with different bound ",(0,i.kt)("em",{parentName:"p"},"figures"),". ",(0,i.kt)("inlineCode",{parentName:"p"},"Pattern::template()"),"\naccepts a regular expression with placeholders, but without any bound figures. Afterwards, at\na later stage, a new pattern can be instantiated from the template, with bound ",(0,i.kt)("em",{parentName:"p"},"figures"),".\n",(0,i.kt)("inlineCode",{parentName:"p"},"Pattern::template()")," accepts a single ",(0,i.kt)("em",{parentName:"p"},"placeholder")," in the template, as opposed to ",(0,i.kt)("inlineCode",{parentName:"p"},"Pattern::builder()"),",\nwhich accepts varying number of ",(0,i.kt)("em",{parentName:"p"},"placeholders"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-php"},"/* Create your template */\n$template = Pattern::template('^(my|your):@$');\n\n/* Instantiate the pattern */\n$pattern1 = $template->literal($_GET['value1']);\n$pattern2 = $template->literal($_GET['value2']);\n")),(0,i.kt)("p",null,"Modifiers can be passed as the second argument in ",(0,i.kt)("inlineCode",{parentName:"p"},"Pattern::template()"),", for example ",(0,i.kt)("inlineCode",{parentName:"p"},"Pattern::template('^(my|your):@$', 'i')"),"."),(0,i.kt)("p",null,"Using ",(0,i.kt)("inlineCode",{parentName:"p"},"Pattern::template()")," has the added advantage of parsing and compiling the pattern early,\nand deferring binding of the ",(0,i.kt)("em",{parentName:"p"},"figures")," for the later time. A common use-case is instantiating\n",(0,i.kt)("inlineCode",{parentName:"p"},"Pattern::template()")," in a constructor of your domain class, and only binding the ",(0,i.kt)("em",{parentName:"p"},"figure")," in\nthe instance method. Perhaps the method argument can be bound as a ",(0,i.kt)("em",{parentName:"p"},"figure"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-php"},"class Checker {\n  private Template $template;\n  \n  public function __construct() {\n    $this->template = Pattern::template('^word:@$');\n  }\n  \n  public function test(string $word, string $subject): bool {\n    $pattern = $this->template->literal($word);\n    return $pattern->test($subject);\n  }\n}\n")),(0,i.kt)("p",null,"If multiple patterns are only different in the values they bind, it's recommended to create a\ntemplate earlier, and insert the exact values in the later stage. Instantiating a new pattern\neach time can be wasteful for big regular expressions:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-php"},"foreach ($values as $value) {\n  $pattern = Pattern::inject('^@$', [$value]);  // expensive\n}\n")),(0,i.kt)("p",null,"compared to creating the template first:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-php"},"$template = Pattern::template('^@$'); // construct once\nforeach ($values as $value) {\n  $pattern = $template->literal($value);  // optimal\n}\n")),(0,i.kt)("p",null,"This is not to say ",(0,i.kt)("inlineCode",{parentName:"p"},"Pattern::inject()")," is not to be used. If a certain ",(0,i.kt)("em",{parentName:"p"},"template")," is only going\nto be used once, then pre-compiling it with ",(0,i.kt)("inlineCode",{parentName:"p"},"Pattern::template()")," doesn't yield any performance\ngain and ",(0,i.kt)("inlineCode",{parentName:"p"},"Pattern::inject()")," is equally viable. On the other hand, using ",(0,i.kt)("inlineCode",{parentName:"p"},"Pattern::template()"),"\ncan still be beneficial to compile the template early, rather than later, for example in the\ndomain class constructor."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"Pattern::template()")," is a shorthand interface for ",(0,i.kt)("inlineCode",{parentName:"p"},"Pattern::builder()"),". ",(0,i.kt)("inlineCode",{parentName:"p"},"Pattern::builder()"),"\nexposes an interface which binds multiple figures. Final call to ",(0,i.kt)("inlineCode",{parentName:"p"},"bind()")," instantiates the\nconstructed ",(0,i.kt)("inlineCode",{parentName:"p"},"Pattern"),". ",(0,i.kt)("inlineCode",{parentName:"p"},"Pattern::template()")," is a shorthand, which only accepts a single bound\nfigure, yet it is completely sufficient, as ",(0,i.kt)("inlineCode",{parentName:"p"},"Pattern::template()")," covers 95% of prepared pattern\nuse-cases."),(0,i.kt)("h3",{id:"pre-compiling-templates-with-multiple-figures"},"Pre-compiling templates with multiple figures"),(0,i.kt)("p",null,"Binding a single ",(0,i.kt)("em",{parentName:"p"},"figure")," into the ",(0,i.kt)("em",{parentName:"p"},"template")," is the majority of use cases. Should that not be\nthe case, ",(0,i.kt)("inlineCode",{parentName:"p"},"Pattern::builder()"),' can be used to bind multiple values and also allows to construct\nthe template early. The word "builder" in ',(0,i.kt)("inlineCode",{parentName:"p"},"Pattern::builder()")," refers to ",(0,i.kt)("inlineCode",{parentName:"p"},"TemplateBuilder"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-php"},"/* Create your template with builder */\n$template = Pattern::builder('^(my|your):@:@$');\n\n/* Instantiate the pattern */\n$pattern = $template->literal($_GET['first'])->literal($_GET['second'])->build();\n")),(0,i.kt)("p",null,"The number of ",(0,i.kt)("em",{parentName:"p"},"placeholders")," ",(0,i.kt)("inlineCode",{parentName:"p"},"@")," in the ",(0,i.kt)("em",{parentName:"p"},"template")," and the number of chained ",(0,i.kt)("inlineCode",{parentName:"p"},"literal()")," calls\nmust be equal. When too many or too little ",(0,i.kt)("em",{parentName:"p"},"figures")," is bound into the ",(0,i.kt)("em",{parentName:"p"},"template"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"PlaceholderFigureException"),"\nis thrown and instantiation of ",(0,i.kt)("inlineCode",{parentName:"p"},"Pattern")," fails."),(0,i.kt)("p",null,"Calling ",(0,i.kt)("inlineCode",{parentName:"p"},"Pattern::builder()")," and only using a single ",(0,i.kt)("inlineCode",{parentName:"p"},"->literal()")," is in fact identical to calling\n",(0,i.kt)("inlineCode",{parentName:"p"},"Pattern::template()->literal()"),"."),(0,i.kt)("p",null,"Let's take a look at the example above, but with ",(0,i.kt)("inlineCode",{parentName:"p"},"TemplateBuilder")," used, instead of previous ",(0,i.kt)("inlineCode",{parentName:"p"},"Template"),",\nso that the ",(0,i.kt)("em",{parentName:"p"},"template")," can consist of two ",(0,i.kt)("inlineCode",{parentName:"p"},"@")," placeholders, with one figure being bound in the\nconstructor, and the second in the instance method."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-php"},"class Checker {\n  private TemplateBuilder $template;\n  \n  public function __construct(string $first) {\n    $this->template = Pattern::builder('^@:@$')->literal($first);\n  }\n  \n  public function test(string $second, string $subject): bool {\n    $pattern = $this->template->literal($word)->build();\n    return $pattern->test($subject);\n  }\n}\n")),(0,i.kt)("p",null,"Calls to ",(0,i.kt)("inlineCode",{parentName:"p"},"->literal()")," can be safely refactored, since ",(0,i.kt)("inlineCode",{parentName:"p"},"Pattern::builder()")," is immutable."),(0,i.kt)("h2",{id:"pcre-styled-patterns"},"PCRE-styled patterns"),(0,i.kt)("p",null,"Should there be a need for your own delimiters, ",(0,i.kt)("inlineCode",{parentName:"p"},"PcrePattern")," can be used. ",(0,i.kt)("inlineCode",{parentName:"p"},"PcrePattern")," offers\nsimilar entry points (",(0,i.kt)("inlineCode",{parentName:"p"},"PcrePattern::of()"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"PcrePattern::inject()"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"PcrePattern::list()"),"), with\nthe difference that the regular expressions must already be delimited and have their modifiers\nappended. ",(0,i.kt)("inlineCode",{parentName:"p"},"PcrePatterns")," still accepts ",(0,i.kt)("em",{parentName:"p"},"placeholders")," ",(0,i.kt)("inlineCode",{parentName:"p"},"@")," in their templates, for example with\n",(0,i.kt)("inlineCode",{parentName:"p"},"PcrePattern::template()"),"."),(0,i.kt)("p",null,"Example of ",(0,i.kt)("inlineCode",{parentName:"p"},"PcrePattern::inject()"),", with pcre-styled ",(0,i.kt)("em",{parentName:"p"},"template")," and ",(0,i.kt)("em",{parentName:"p"},"figure")," containing the delimiter ",(0,i.kt)("inlineCode",{parentName:"p"},"%"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-php"},"$linkPattern = PcrePattern::inject(\"%https?://@/index\\.php%m\", ['one%two']);\n")),(0,i.kt)("p",null,"Pattern ",(0,i.kt)("inlineCode",{parentName:"p"},"$linkPattern")," can be analyzed: ",(0,i.kt)("inlineCode",{parentName:"p"},"%")," is a delimiter stating the start of PCRE regular\nexpression, ",(0,i.kt)("inlineCode",{parentName:"p"},"http")," matches ",(0,i.kt)("inlineCode",{parentName:"p"},'"http"'),", ",(0,i.kt)("inlineCode",{parentName:"p"},"s?")," matches either ",(0,i.kt)("inlineCode",{parentName:"p"},'"s"')," or nothing at all, ",(0,i.kt)("inlineCode",{parentName:"p"},"://")," matches\n",(0,i.kt)("inlineCode",{parentName:"p"},'"://"'),", placeholder ",(0,i.kt)("inlineCode",{parentName:"p"},"@")," matches ",(0,i.kt)("inlineCode",{parentName:"p"},'"one%two"')," literally, ",(0,i.kt)("inlineCode",{parentName:"p"},"index")," matches ",(0,i.kt)("inlineCode",{parentName:"p"},'"index"'),", escaped ",(0,i.kt)("inlineCode",{parentName:"p"},"\\."),"\nmatches ",(0,i.kt)("inlineCode",{parentName:"p"},'"."'),", ",(0,i.kt)("inlineCode",{parentName:"p"},"php")," matches ",(0,i.kt)("inlineCode",{parentName:"p"},'"php"'),", final ",(0,i.kt)("inlineCode",{parentName:"p"},"%")," states the end of regular expression, ",(0,i.kt)("inlineCode",{parentName:"p"},"m")," is a modifier."),(0,i.kt)("p",null,"Corresponding methods ",(0,i.kt)("inlineCode",{parentName:"p"},"PcrePattern::template()")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"PcrePattern::builder()")," work accordingly."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"PcrePattern")," entry points return instance of ",(0,i.kt)("inlineCode",{parentName:"p"},"Pattern"),", so the resulting pattern can be used as\nany other T-Regx ",(0,i.kt)("inlineCode",{parentName:"p"},"Pattern"),"."),(0,i.kt)("h2",{id:"frequently-asked-questions"},"Frequently asked questions"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"How do I pass modifiers (flags) into ",(0,i.kt)("inlineCode",{parentName:"p"},"Pattern::inject()")," and other entry points?"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Modifiers can be passed as the third argument in ",(0,i.kt)("inlineCode",{parentName:"p"},"Pattern::inject()"),". For example, passing ",(0,i.kt)("inlineCode",{parentName:"p"},"i")," (case-insensitive) modifier:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-php"},"Pattern::inject('^@$', [$input], 'i');\n")),(0,i.kt)("p",{parentName:"li"},"Remaining entry points accept modifiers as the second argument:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-php"},"Pattern::template('^@$', 'i');\nPattern::builder('^@$', 'i');\n"))))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Is passing an empty ",(0,i.kt)("inlineCode",{parentName:"p"},"string")," as ",(0,i.kt)("em",{parentName:"p"},"figure")," allowed?"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Yes - absolutely, an empty string is a perfectly valid ",(0,i.kt)("em",{parentName:"p"},"figure"),". For example, template ",(0,i.kt)("inlineCode",{parentName:"p"},"<@>")," with\nbound ",(0,i.kt)("em",{parentName:"p"},"figure")," of an empty string: ",(0,i.kt)("inlineCode",{parentName:"p"},"Pattern::inject('<@>', [\"\"])")," - matches string ",(0,i.kt)("inlineCode",{parentName:"p"},'"<>"')," just fine."),(0,i.kt)("p",{parentName:"li"},"Furthermore, placeholders ",(0,i.kt)("inlineCode",{parentName:"p"},"@?")," with quantifiers also work with empty strings. For example:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},'$wordPattern = Pattern::inject("^word:@?$", [""]);\n')),(0,i.kt)("p",{parentName:"li"},"In this example, ",(0,i.kt)("inlineCode",{parentName:"p"},"$wordPattern")," matches subject ",(0,i.kt)("inlineCode",{parentName:"p"},'"word:"'),", but not ",(0,i.kt)("inlineCode",{parentName:"p"},'"word"'),". For the pattern to match\n",(0,i.kt)("inlineCode",{parentName:"p"},'"word"'),", an alternative template is needed, namely: ",(0,i.kt)("inlineCode",{parentName:"p"},"^word(:@)?$"),"."),(0,i.kt)("p",{parentName:"li"},"In other words, if the bound ",(0,i.kt)("em",{parentName:"p"},"figure")," matches 0 characters, by regular expression, so does the\ncorresponding ",(0,i.kt)("inlineCode",{parentName:"p"},"@")," placeholder.")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Is passing an empty ",(0,i.kt)("inlineCode",{parentName:"p"},"array")," of figures to ",(0,i.kt)("inlineCode",{parentName:"p"},"Pattern::inject()")," allowed?"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"If the ",(0,i.kt)("em",{parentName:"p"},"template")," doesn't contain any ",(0,i.kt)("em",{parentName:"p"},"placeholders")," ",(0,i.kt)("inlineCode",{parentName:"p"},"@"),", then actually an empty\n",(0,i.kt)("inlineCode",{parentName:"p"},"array")," is the only allowed input, although it's identical to simply calling ",(0,i.kt)("inlineCode",{parentName:"p"},"Pattern::of()"),"."),(0,i.kt)("p",{parentName:"li"},"By analogy, the same applies to ",(0,i.kt)("inlineCode",{parentName:"p"},"Pattern::builder()"),". When ",(0,i.kt)("em",{parentName:"p"},"template")," doesn't contain any ",(0,i.kt)("inlineCode",{parentName:"p"},"@"),"\nplaceholder, then no chain of ",(0,i.kt)("inlineCode",{parentName:"p"},"->literal()")," is allowed before ",(0,i.kt)("inlineCode",{parentName:"p"},"->bind()"),". Needless to say,\nsuch construct is identical to ",(0,i.kt)("inlineCode",{parentName:"p"},"Pattern::of()")," and is only present in the API for completeness.")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Is ",(0,i.kt)("inlineCode",{parentName:"p"},"Pattern::of($p)")," identical to ",(0,i.kt)("inlineCode",{parentName:"p"},"Pattern::inject($p, [])"),"?"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Yes, provided that ",(0,i.kt)("inlineCode",{parentName:"li"},"$p")," doesn't contain unescaped ",(0,i.kt)("inlineCode",{parentName:"li"},"@")," special character (which would be\na ",(0,i.kt)("em",{parentName:"li"},"placeholder")," in ",(0,i.kt)("inlineCode",{parentName:"li"},"Pattern::inject()"),")."))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"How can character ",(0,i.kt)("inlineCode",{parentName:"p"},'"@"')," be used literally in the pattern?"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Escaped character ",(0,i.kt)("inlineCode",{parentName:"p"},"\\@")," is not treated as a placeholder, for example:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-php"},'$username = "mark";\n$mailPattern = Pattern::inject("@\\@gmail.com", [$username]);\n')),(0,i.kt)("p",{parentName:"li"},"In the example above, ",(0,i.kt)("inlineCode",{parentName:"p"},"Pattern")," in ",(0,i.kt)("inlineCode",{parentName:"p"},"$mailPattern")," matches subject ",(0,i.kt)("inlineCode",{parentName:"p"},'"mark@gmail.com"'),"."),(0,i.kt)("p",{parentName:"li"},"More details on when exactly ",(0,i.kt)("inlineCode",{parentName:"p"},"@")," is a ",(0,i.kt)("em",{parentName:"p"},"placeholder")," can be found in the next chapter:\n",(0,i.kt)("a",{parentName:"p",href:"/docs/template-syntax"},"Template Syntax"),"."))))),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"What happens when I pass string ",(0,i.kt)("inlineCode",{parentName:"p"},'"@"')," as a figure. Will it recurse placeholders?"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"No, character ",(0,i.kt)("inlineCode",{parentName:"li"},'"@"')," passed as a figure will be treated as another literal, for example:",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"Pattern::inject('^@:@$', ['word', '@']);\n")),"Instance of the ",(0,i.kt)("inlineCode",{parentName:"li"},"Pattern")," above will match subject ",(0,i.kt)("inlineCode",{parentName:"li"},'"word:@"'),", though it won't construct\noptimal regular expression. Escaping the ",(0,i.kt)("inlineCode",{parentName:"li"},"@")," character is the recommended approach:",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"Pattern::inject('^@:@$', ['word', '@']);  // not optimal\nPattern::inject('^@:\\@$', ['word']);      // optimal\n")),"Escaping ",(0,i.kt)("inlineCode",{parentName:"li"},"@")," character is not only optimal performance-wise, but is also more readable."))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Can figures influence the construction of the ",(0,i.kt)("inlineCode",{parentName:"p"},"Pattern"),", for example by taking part in\nthe selection of the delimiter?"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"No, the ",(0,i.kt)("em",{parentName:"p"},"template")," is assigned a delimiter regardless of the ",(0,i.kt)("em",{parentName:"p"},"figures")," bound to it.\nFor example:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"$value = \"/\"; // slash, a standard delimiter\n\n/* Render the regular expression, for debugging purposes */\necho (string) Pattern::inject('^@$', [$value]); \n")),(0,i.kt)("p",{parentName:"li"},"constructs a pattern with standard ",(0,i.kt)("inlineCode",{parentName:"p"},"/")," delimiter, with figure ",(0,i.kt)("inlineCode",{parentName:"p"},'"/"')," being properly escaped:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"/^\\/$/\n")))))),(0,i.kt)("h2",{id:"what-about-special-cases"},"What about special cases"),(0,i.kt)("p",null,"T-Regx prepared patterns understand that sometimes ",(0,i.kt)("inlineCode",{parentName:"p"},"@")," figure shouldn't be a placeholder, even\nwhen using ",(0,i.kt)("inlineCode",{parentName:"p"},"Pattern::inject()")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"Pattern::template()"),". "),(0,i.kt)("p",null,"Structures, in which character ",(0,i.kt)("inlineCode",{parentName:"p"},"@")," is ",(0,i.kt)("strong",{parentName:"p"},"not")," a ",(0,i.kt)("em",{parentName:"p"},"placeholder")," (matches ",(0,i.kt)("inlineCode",{parentName:"p"},'"@"')," literally): "),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Escaped character: ",(0,i.kt)("inlineCode",{parentName:"li"},"\\w+:\\@")),(0,i.kt)("li",{parentName:"ul"},"Character class: ",(0,i.kt)("inlineCode",{parentName:"li"},"\\w+:[0-9@]")),(0,i.kt)("li",{parentName:"ul"},"Perl quote: ",(0,i.kt)("inlineCode",{parentName:"li"},"\\w+:\\Q@\\E")),(0,i.kt)("li",{parentName:"ul"},"Control character: ",(0,i.kt)("inlineCode",{parentName:"li"},"\\w+:\\c@")),(0,i.kt)("li",{parentName:"ul"},"Comment group: ",(0,i.kt)("inlineCode",{parentName:"li"},"\\w(?#comment@)")),(0,i.kt)("li",{parentName:"ul"},"Comment (when ",(0,i.kt)("inlineCode",{parentName:"li"},"x")," flag is used): ",(0,i.kt)("inlineCode",{parentName:"li"},"\\w+:#@\\n"))),(0,i.kt)("p",null,"Other cases, when ",(0,i.kt)("inlineCode",{parentName:"p"},"@")," placeholder can be used are:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Capturing groups: ",(0,i.kt)("inlineCode",{parentName:"li"},"(word:@)")," (figure bound to ",(0,i.kt)("inlineCode",{parentName:"li"},"@")," is captured)"),(0,i.kt)("li",{parentName:"ul"},"Non-capturing groups: ",(0,i.kt)("inlineCode",{parentName:"li"},"(?:word:@)")," (figure bound to ",(0,i.kt)("inlineCode",{parentName:"li"},"@")," is ",(0,i.kt)("strong",{parentName:"li"},"not")," captured)"),(0,i.kt)("li",{parentName:"ul"},"Atomic capturing groups: ",(0,i.kt)("inlineCode",{parentName:"li"},"(?>word:@)")),(0,i.kt)("li",{parentName:"ul"},"Look-aheads: ",(0,i.kt)("inlineCode",{parentName:"li"},'(?="@")')),(0,i.kt)("li",{parentName:"ul"},"Look-behinds: ",(0,i.kt)("inlineCode",{parentName:"li"},'(?<="@")'))),(0,i.kt)("p",null,"More details on when exactly ",(0,i.kt)("inlineCode",{parentName:"p"},"@")," is a ",(0,i.kt)("em",{parentName:"p"},"placeholder")," can be found in the next chapter: ",(0,i.kt)("a",{parentName:"p",href:"/docs/template-syntax"},"Template Syntax"),"."),(0,i.kt)("h2",{id:"terminology"},"Terminology"),(0,i.kt)("p",null,'There are 4 new terms introduced with prepared patterns in this chapter: "Prepared patterns", "template",\n"placeholder" and "figure".'),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},'"Prepared patterns" is a common name for the interface for safe construction of instances of ',(0,i.kt)("inlineCode",{parentName:"p"},"Pattern")," with arbitrary\nvalues (like dynamic strings). In this documentation, entry points ",(0,i.kt)("inlineCode",{parentName:"p"},"Pattern::inject()")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Pattern::template()"),'\nare referred to as "prepared patterns". In other words, "prepared patterns" are patterns with ',(0,i.kt)("inlineCode",{parentName:"p"},"@")," placeholder\nin them."),(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"Pattern::of()"),' is not referred to as "prepared pattern", because while character ',(0,i.kt)("inlineCode",{parentName:"p"},'"@"')," can very well\nbe used in the regular expression with ",(0,i.kt)("inlineCode",{parentName:"p"},"of()")," (for example ",(0,i.kt)("inlineCode",{parentName:"p"},"Pattern::of('\\w+@\\w+.\\w+')"),"), it is not a\nplaceholder. Character ",(0,i.kt)("inlineCode",{parentName:"p"},'"@"')," used in ",(0,i.kt)("inlineCode",{parentName:"p"},"Pattern::of()")," matches character ",(0,i.kt)("inlineCode",{parentName:"p"},'"@"')," literally, where-as\nplaceholders ",(0,i.kt)("inlineCode",{parentName:"p"},"@")," in ",(0,i.kt)("inlineCode",{parentName:"p"},"Pattern::inject()")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Pattern:template()")," will match the values that will have\nbeen bound to them."),(0,i.kt)("p",{parentName:"li"},"More details on when exactly ",(0,i.kt)("inlineCode",{parentName:"p"},"@")," is a ",(0,i.kt)("em",{parentName:"p"},"placeholder")," can be found in the next chapter:\n",(0,i.kt)("a",{parentName:"p",href:"/docs/template-syntax"},"Template Syntax"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},'"template" is a name for a regular expression that contains ',(0,i.kt)("inlineCode",{parentName:"p"},"@")," ",(0,i.kt)("em",{parentName:"p"},"placeholder")," in it, and can later\nbe bound to certain ",(0,i.kt)("em",{parentName:"p"},"figures")," or character which will match in place of ",(0,i.kt)("inlineCode",{parentName:"p"},"@")," ",(0,i.kt)("em",{parentName:"p"},"placeholder"),". Entry\npoints ",(0,i.kt)("inlineCode",{parentName:"p"},"Pattern::inject()")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Pattern::template()")," accept ",(0,i.kt)("em",{parentName:"p"},"template")," as their first argument."),(0,i.kt)("p",{parentName:"li"},"More details on when exactly ",(0,i.kt)("inlineCode",{parentName:"p"},"@")," is a ",(0,i.kt)("em",{parentName:"p"},"placeholder")," can be found in the next chapter:\n",(0,i.kt)("a",{parentName:"p",href:"/docs/template-syntax"},"Template Syntax"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},'"placeholder" is a name for a figure ',(0,i.kt)("inlineCode",{parentName:"p"},"@")," appearing in a ",(0,i.kt)("em",{parentName:"p"},"template"),". Not every occurrence of ",(0,i.kt)("inlineCode",{parentName:"p"},"@"),"\nin a regular expression is a ",(0,i.kt)("em",{parentName:"p"},"placeholder"),". For example, escaped ",(0,i.kt)("inlineCode",{parentName:"p"},"\\@")," is not a ",(0,i.kt)("em",{parentName:"p"},"placeholder"),",\nand so will match character ",(0,i.kt)("inlineCode",{parentName:"p"},'"@"')," literally."),(0,i.kt)("p",{parentName:"li"},"More details on when exactly ",(0,i.kt)("inlineCode",{parentName:"p"},"@")," is a ",(0,i.kt)("em",{parentName:"p"},"placeholder")," can be found in the next chapter:\n",(0,i.kt)("a",{parentName:"p",href:"/docs/template-syntax"},"Template Syntax"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},'"figure" is a name for anything that can be bound to a ',(0,i.kt)("em",{parentName:"p"},"placeholder"),", most common of which is\na literal ",(0,i.kt)("inlineCode",{parentName:"p"},"string"),", but can also be an alteration, another pattern or a mask."))))}c.isMDXComponent=!0}}]);