"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[3069],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>h});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var p=a.createContext({}),s=function(e){var t=a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=s(e.components);return a.createElement(p.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,p=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),c=s(n),h=r,u=c["".concat(p,".").concat(h)]||c[h]||m[h]||i;return n?a.createElement(u,o(o({ref:t},d),{},{components:n})):a.createElement(u,o({ref:t},d))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=c;var l={};for(var p in t)hasOwnProperty.call(t,p)&&(l[p]=t[p]);l.originalType=e,l.mdxType="string"==typeof e?e:r,o[1]=l;for(var s=2;s<i;s++)o[s]=n[s];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},1746:(e,t,n)=>{n.r(t),n.d(t,{default:()=>m,frontMatter:()=>l,metadata:()=>p,toc:()=>s});var a=n(7462),r=n(3366),i=(n(7294),n(3905)),o=["components"],l={id:"introduction-preg",title:"Summary of preg methods"},p={unversionedId:"introduction-preg",id:"introduction-preg",isDocsHomePage:!1,title:"Summary of preg methods",description:"Should you choose not to use Pattern and other object-oriented functionalities of T-Regx,",source:"@site/../docs/introduction-preg.md",sourceDirName:".",slug:"/introduction-preg",permalink:"/docs/introduction-preg",version:"current",lastUpdatedAt:1669695161,formattedLastUpdatedAt:"11/29/2022",frontMatter:{id:"introduction-preg",title:"Summary of preg methods"},sidebar:"docs",previous:{title:"Introduction to T-Regx",permalink:"/docs/introduction"},next:{title:"Matching overview",permalink:"/docs/match"}},s=[{value:"Summary of <code>preg_</code> methods",id:"summary-of-preg_-methods",children:[]},{value:"About preg methods of T-Regx",id:"about-preg-methods-of-t-regx",children:[]},{value:"What <code>preg::</code> methods really are",id:"what-preg-methods-really-are",children:[{value:"Error handling with <code>preg::</code>",id:"error-handling-with-preg",children:[]}]},{value:"What <code>Pattern</code> really is",id:"what-pattern-really-is",children:[]}],d={toc:s};function m(e){var t=e.components,n=(0,r.Z)(e,o);return(0,i.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Should you choose not to use ",(0,i.kt)("inlineCode",{parentName:"p"},"Pattern")," and other object-oriented functionalities of T-Regx,\nyou can continue to use ",(0,i.kt)("inlineCode",{parentName:"p"},"preg")," methods (",(0,i.kt)("inlineCode",{parentName:"p"},"preg_match()"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"preg_replace()"),", etc.). We recommend\nusing ",(0,i.kt)("inlineCode",{parentName:"p"},"Pattern")," as a standard solution, however ",(0,i.kt)("inlineCode",{parentName:"p"},"preg::")," is available as a legacy alternative."),(0,i.kt)("p",null,"The downside of PHP built-in ",(0,i.kt)("inlineCode",{parentName:"p"},"preg_match()")," functions is their interface, which is not really well-designed.\n",(0,i.kt)("inlineCode",{parentName:"p"},"preg::")," methods aim to be a reliable replacement."),(0,i.kt)("h3",{id:"summary-of-preg_-methods"},"Summary of ",(0,i.kt)("inlineCode",{parentName:"h3"},"preg_")," methods"),(0,i.kt)("p",null,"Here's a simple summary and analysis of PHP built-in ",(0,i.kt)("inlineCode",{parentName:"p"},"preg_")," methods:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Every ",(0,i.kt)("inlineCode",{parentName:"li"},"preg_")," method accepts ",(0,i.kt)("inlineCode",{parentName:"li"},"string $pattern")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"string $subject"),".\nSome methods also accept an array of ",(0,i.kt)("inlineCode",{parentName:"li"},"$pattern")," and an array of ",(0,i.kt)("inlineCode",{parentName:"li"},"string $subject"),".\nThis makes the ",(0,i.kt)("inlineCode",{parentName:"li"},"preg_")," methods inconsistent."),(0,i.kt)("li",{parentName:"ul"},"All of ",(0,i.kt)("inlineCode",{parentName:"li"},"preg_")," methods follow PHP duck-typing convention, so using incorrect types\ncauses ",(0,i.kt)("inlineCode",{parentName:"li"},"preg_")," methods to silently cast them, making the ",(0,i.kt)("inlineCode",{parentName:"li"},"preg_")," methods misbehaves in a very\npeculiar way."),(0,i.kt)("li",{parentName:"ul"},"Some methods return their values, and some populate it via ",(0,i.kt)("inlineCode",{parentName:"li"},"&$ref")," argument.\nOther methods return amounts, and populate result via ",(0,i.kt)("inlineCode",{parentName:"li"},"&$ref")," instead. This is very counter-intuitive."),(0,i.kt)("li",{parentName:"ul"},"Some methods return ",(0,i.kt)("inlineCode",{parentName:"li"},"false")," on error, and others return ",(0,i.kt)("inlineCode",{parentName:"li"},"null"),", instead of simply throwing an exception."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"preg_"),' methods actually have multiple ways of reacting to error: either by returning an "error value"\n(like ',(0,i.kt)("inlineCode",{parentName:"li"},"false"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"null"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"0"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"-1")," or ",(0,i.kt)("inlineCode",{parentName:"li"},'""'),"), or by issuing a PHP warning/notice/error, other methods\nbehaves normally, but set the status code for ",(0,i.kt)("inlineCode",{parentName:"li"},"preg_last_error()"),", yet another cases result in PHP Fatal\nErrors (which terminate the application), and recent updates of PHP actually throw errors on invalid arguments.\nThis makes ",(0,i.kt)("inlineCode",{parentName:"li"},"preg_")," methods very hard to rely on what they will do for faulty input."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"preg_")," functions have a large number of arguments, many have 5-6 arguments (most of which are optional).\nThis makes an interface that is very complex."),(0,i.kt)("li",{parentName:"ul"},"Values populated via ",(0,i.kt)("inlineCode",{parentName:"li"},"&$match")," in ",(0,i.kt)("inlineCode",{parentName:"li"},"preg_match()")," behave differently than ",(0,i.kt)("inlineCode",{parentName:"li"},"$match")," from ",(0,i.kt)("inlineCode",{parentName:"li"},"preg_match_all()"),"\nand follows different rules and criteria, so one can't be always mapped to the other."),(0,i.kt)("li",{parentName:"ul"},"Argument ",(0,i.kt)("inlineCode",{parentName:"li"},"array $match")," passed as argument from ",(0,i.kt)("inlineCode",{parentName:"li"},"preg_replace_callback()")," behaves utterly differently than\nthe previous two."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"preg_")," functions accept magic values, for example passing ",(0,i.kt)("inlineCode",{parentName:"li"},"-1")," as ",(0,i.kt)("inlineCode",{parentName:"li"},"$limit"),' in replacing (which is supposed\nto mean "no limit").\nThis is an influence from C-API that PHP uses internally, but shouldn\'t be exposed to the interface of PHP\nfunctions.'),(0,i.kt)("li",{parentName:"ul"},"Additional functionality is exposed as C-style flags, like ",(0,i.kt)("inlineCode",{parentName:"li"},"PREG_SET_ORDER"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"PREG_CAPTURE_OFFSET"),", etc. for\nbackwards-compatibility. It adds another level of complexity, which in fact isn't necessary."),(0,i.kt)("li",{parentName:"ul"},"Function ",(0,i.kt)("inlineCode",{parentName:"li"},"preg_match_all()")," returns an array of arrays of ",(0,i.kt)("inlineCode",{parentName:"li"},"null|string"),", and when used with ",(0,i.kt)("inlineCode",{parentName:"li"},"PREG_CAPTURE_OFFSET"),",\nthen it's an array of arrays of arrays of ",(0,i.kt)("inlineCode",{parentName:"li"},"null|string|int"),"."),(0,i.kt)("li",{parentName:"ul"},"Matching methods (",(0,i.kt)("inlineCode",{parentName:"li"},"preg_match()")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"preg_match_all()"),") have a very hard time distinguishing an empty matched\ngroup and an unmatched group (because they're both returned as ",(0,i.kt)("inlineCode",{parentName:"li"},'""'),"). There are ways to try and detect it, like\npassing flag ",(0,i.kt)("inlineCode",{parentName:"li"},"PREG_CAPTURE_OFFSET"),", but it has flaws of its one. Major flaw, is that it changes the type from\n",(0,i.kt)("inlineCode",{parentName:"li"},"string")," to an ",(0,i.kt)("inlineCode",{parentName:"li"},"array"),", with the exception if the match is not captured, the return values is still a string.\nSo ",(0,i.kt)("inlineCode",{parentName:"li"},"PREG_CAPTURE_OFFSET")," actually changes type ",(0,i.kt)("inlineCode",{parentName:"li"},"string")," to ",(0,i.kt)("inlineCode",{parentName:"li"},"string|array"),", because the result can still be a ",(0,i.kt)("inlineCode",{parentName:"li"},"string"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"preg_"),' methods can\'t distinguish an unmatched group from a nonexistent group, because the last group in the match,\nshould it be unmatched, will not be present in the result (instead of being simply present like the remaining groups).\nThis makes the interface less reliable and prone to "array undefined index" errors.'),(0,i.kt)("li",{parentName:"ul"},"Different PHP versions react to different inputs in different ways. Error messages between PHP versions vary."),(0,i.kt)("li",{parentName:"ul"},"Some method names are very unintuitive. For example ",(0,i.kt)("inlineCode",{parentName:"li"},"preg_filter()")," appears as a method for filtering collections,\nbut it actually ",(0,i.kt)("em",{parentName:"li"},"replaces")," values. In fact, it's very similar to ",(0,i.kt)("inlineCode",{parentName:"li"},"preg_replace()"),", but the function names doesn't\nillustrate it at all. The function that actually filters an array by a regular expressions is called ",(0,i.kt)("inlineCode",{parentName:"li"},"preg_grep()"),",\nname borrowed from Unix ",(0,i.kt)("inlineCode",{parentName:"li"},"grep")," command."),(0,i.kt)("li",{parentName:"ul"},"Different dialects of regular expressions are actually accepted, because PHP 7.4 uses PCRE2, whereas older versions\nuse PCRE1."),(0,i.kt)("li",{parentName:"ul"},"There is no standard way of using regular expressions with plain text. The only available method is ",(0,i.kt)("inlineCode",{parentName:"li"},"preg_quote()"),",\nbut it doesn't work at all with ",(0,i.kt)("inlineCode",{parentName:"li"},"/x")," modifier, as it doesn't escape whitespace and comment syntax (starting ",(0,i.kt)("inlineCode",{parentName:"li"},"#")," and\nending newline), which makes ",(0,i.kt)("inlineCode",{parentName:"li"},"preg_quote()")," completely unreliable with extended mode."),(0,i.kt)("li",{parentName:"ul"},"The syntax of regular expressions and what is allowed in the expression changes between PHP versions.")),(0,i.kt)("p",null,"Some flaws described above are solved by successor ",(0,i.kt)("inlineCode",{parentName:"p"},"preg::match()"),",",(0,i.kt)("inlineCode",{parentName:"p"},"preg::replace()")," methods, but it's not always possible.\nFor example improving the interface of the methods is not really possible with ",(0,i.kt)("inlineCode",{parentName:"p"},"preg::match()"),". For that case ",(0,i.kt)("inlineCode",{parentName:"p"},"Pattern"),"\ninterface is available to solve all the other remaining issues and is the recommended approach."),(0,i.kt)("h2",{id:"about-preg-methods-of-t-regx"},"About preg methods of T-Regx"),(0,i.kt)("p",null,"When T-Regx is added to a project, both methods can be used. The preferable method is using the standard ",(0,i.kt)("inlineCode",{parentName:"p"},"Pattern")," interface,\nbut ",(0,i.kt)("inlineCode",{parentName:"p"},"preg::match()")," remains available for legacy projects that are not ready to be migrated yet. Using ",(0,i.kt)("inlineCode",{parentName:"p"},"Pattern"),"\ndoesn't have anything to do with ",(0,i.kt)("inlineCode",{parentName:"p"},"preg_")," methods, so knowing them isn't required to use ",(0,i.kt)("inlineCode",{parentName:"p"},"Pattern"),"."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Pattern")," - the standard solution for regular expressions"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"preg::match()")," and other methods - the wrapper on PHP functions (making the ",(0,i.kt)("inlineCode",{parentName:"li"},"preg_")," methods throw exceptions).")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"Pattern")," is the complete solution to using regular expressions in PHP. It solves all issues with ",(0,i.kt)("inlineCode",{parentName:"p"},"preg_")," methods above.\nIt's descriptive, simple and easy to learn. ",(0,i.kt)("inlineCode",{parentName:"p"},"Pattern")," uses exceptions, since warnings and errors are less reliable. It's\ndesigned with care and dedication."),(0,i.kt)("p",null,"On the off-chance that using ",(0,i.kt)("inlineCode",{parentName:"p"},"Pattern")," is unwanted in a project (perhaps because migrating it would require too much effort),\n",(0,i.kt)("inlineCode",{parentName:"p"},"preg::")," alternative is available. ",(0,i.kt)("inlineCode",{parentName:"p"},"preg::")," functions' interface is very similar to ",(0,i.kt)("inlineCode",{parentName:"p"},"preg_")," functions' interface, so\nadopting ",(0,i.kt)("inlineCode",{parentName:"p"},"preg::")," is simple and straightforward, and in return provides safety layer of protection, type-checking,\nbugfixes and exceptions on ",(0,i.kt)("inlineCode",{parentName:"p"},"preg_")," methods. Once the migration is complete, a speedy eventual migration to ",(0,i.kt)("inlineCode",{parentName:"p"},"Pattern"),"\ngives even more advantages."),(0,i.kt)("p",null,"Each ",(0,i.kt)("inlineCode",{parentName:"p"},"preg_")," method has a ",(0,i.kt)("inlineCode",{parentName:"p"},"preg::")," counter-part: ",(0,i.kt)("inlineCode",{parentName:"p"},"preg_match()")," -> ",(0,i.kt)("inlineCode",{parentName:"p"},"preg::match()"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"preg_replace()")," -> ",(0,i.kt)("inlineCode",{parentName:"p"},"preg::replace()"),".\nThe ",(0,i.kt)("inlineCode",{parentName:"p"},"preg::")," counter-parts have a very similar interface (same arguments, same types, same names, similar behaviour)."),(0,i.kt)("p",null,"The main difference between ",(0,i.kt)("inlineCode",{parentName:"p"},"preg_")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"preg::")," functions is reacting to errors and faulty inputs. While ",(0,i.kt)("inlineCode",{parentName:"p"},"preg_")," methods\nreact in a number of different, inconsistent manners (returning ",(0,i.kt)("inlineCode",{parentName:"p"},"null"),"/",(0,i.kt)("inlineCode",{parentName:"p"},"false"),", issuing warning/notice, setting code for\n",(0,i.kt)("inlineCode",{parentName:"p"},"preg_last_error()"),"), ",(0,i.kt)("inlineCode",{parentName:"p"},"preg::")," doesn't do any of those, and throws suitable exceptions instead. So while the return type\nof ",(0,i.kt)("inlineCode",{parentName:"p"},"preg_match()")," is ",(0,i.kt)("inlineCode",{parentName:"p"},"int|false")," (since it can either return an integer, or ",(0,i.kt)("inlineCode",{parentName:"p"},"false")," on error) the return type of\n",(0,i.kt)("inlineCode",{parentName:"p"},"preg::match()")," is ",(0,i.kt)("inlineCode",{parentName:"p"},"int"),". ",(0,i.kt)("inlineCode",{parentName:"p"},"preg::match()")," never returns ",(0,i.kt)("inlineCode",{parentName:"p"},"false")," to indicate an error, because a suitable exception is thrown\nin that case."),(0,i.kt)("p",null,"There are other advantages to using ",(0,i.kt)("inlineCode",{parentName:"p"},"preg::")," methods, for example bugfixes. PHP bugfixes are only applied to future PHP\nversions. On the contrary, ",(0,i.kt)("inlineCode",{parentName:"p"},"preg::")," back-ports the bugfixes to earlier versions. That means, T-Regx can be used on PHP 7.1,\nwithout being susceptible to the bug, that was only fixed in PHP 7.3. In fact, we believe each given T-Regx release will\nbehave exactly the same on all supported PHP versions. Of course there are changes between distinct T-Regx versions,\nbut each given T-Regx version should be agnostic to PHP version."),(0,i.kt)("p",null,"Another big advantage of using ",(0,i.kt)("inlineCode",{parentName:"p"},"preg::")," is the type-checking. ",(0,i.kt)("inlineCode",{parentName:"p"},"preg_")," methods will accept a wide range of types and then\nsilently cast them. ",(0,i.kt)("inlineCode",{parentName:"p"},"preg::")," will accept only the exact types, and throw PHP ",(0,i.kt)("inlineCode",{parentName:"p"},"\\InvalidArgumentException")," instead. Passing\n",(0,i.kt)("inlineCode",{parentName:"p"},"false")," as ",(0,i.kt)("inlineCode",{parentName:"p"},"$subject")," is never a good idea. Callbacks passed to ",(0,i.kt)("inlineCode",{parentName:"p"},"preg_replace_callback()")," also perform silent type cast,\nwhen the type isn't ",(0,i.kt)("inlineCode",{parentName:"p"},"string"),". Furthermore, passing improper values as a callback return value ",(0,i.kt)("inlineCode",{parentName:"p"},"preg_replace_callback()"),"\ncan result in a PHP fatal error, which terminates the application and can't be caught. ",(0,i.kt)("inlineCode",{parentName:"p"},"preg::replace_callback()")," type\nchecks return values, and allows only the allowed values, and throws an exception instead, preventing the fatal error."),(0,i.kt)("p",null,"Using ",(0,i.kt)("inlineCode",{parentName:"p"},"preg::last_error()")," is redundant, because ",(0,i.kt)("inlineCode",{parentName:"p"},"preg::")," methods will always throw an exception on error, so there isn't\na need of ever using ",(0,i.kt)("inlineCode",{parentName:"p"},"preg::last_error()"),"."),(0,i.kt)("p",null,"With ",(0,i.kt)("inlineCode",{parentName:"p"},"preg_")," methods, there really isn't a good way to react to a malformed pattern. ",(0,i.kt)("inlineCode",{parentName:"p"},'preg_match("/?/")')," doesn't set\n",(0,i.kt)("inlineCode",{parentName:"p"},"preg_last_error()")," code. Granted, the case of using improper regular expression isn't a particularly frequent use-case,\nnevertheless ",(0,i.kt)("inlineCode",{parentName:"p"},"preg::")," throws a proper ",(0,i.kt)("inlineCode",{parentName:"p"},"MalformedPatternException")," for that case. Errors should never pass silently,\nunless explicitly silenced, which is now possible with ",(0,i.kt)("inlineCode",{parentName:"p"},"preg::")," exceptions and ",(0,i.kt)("inlineCode",{parentName:"p"},"try"),"/",(0,i.kt)("inlineCode",{parentName:"p"},"catch")," for example."),(0,i.kt)("h2",{id:"what-preg-methods-really-are"},"What ",(0,i.kt)("inlineCode",{parentName:"h2"},"preg::")," methods really are"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"preg::")," methods are wrapper functions for each ",(0,i.kt)("inlineCode",{parentName:"p"},"preg_")," methods, with specific improvements on top:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Handling regex-compile errors, like malformed patterns, and throwing proper exceptions, for example ",(0,i.kt)("inlineCode",{parentName:"li"},"MalformedPatternException")),(0,i.kt)("li",{parentName:"ul"},"Handling regex-runtime errors, like catastrophic backtracking and throwing proper ",(0,i.kt)("inlineCode",{parentName:"li"},"CatastrophicBacktrackingPregException")," exception"),(0,i.kt)("li",{parentName:"ul"},"Performing type-checks on input arguments and return values from callbacks"),(0,i.kt)("li",{parentName:"ul"},"Applies bugfixes to ",(0,i.kt)("inlineCode",{parentName:"li"},"preg_")," methods from future PHP versions (or even bugfixes not yet applied to PHP)."),(0,i.kt)("li",{parentName:"ul"},"Preventing fatal errors")),(0,i.kt)("p",null,"Read on, to learn about advantages of using ",(0,i.kt)("inlineCode",{parentName:"p"},"Pattern"),", which supersedes ",(0,i.kt)("inlineCode",{parentName:"p"},"preg_"),"/",(0,i.kt)("inlineCode",{parentName:"p"},"preg::")," approach."),(0,i.kt)("h3",{id:"error-handling-with-preg"},"Error handling with ",(0,i.kt)("inlineCode",{parentName:"h3"},"preg::")),(0,i.kt)("p",null,"With PHP ",(0,i.kt)("inlineCode",{parentName:"p"},"preg_")," methods, multiple ",(0,i.kt)("inlineCode",{parentName:"p"},"preg_")," methods used together, for instance calling ",(0,i.kt)("inlineCode",{parentName:"p"},"preg_match()"),",\n",(0,i.kt)("inlineCode",{parentName:"p"},"preg_replace()"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"preg_split()")," right after each other, may render the error handling really tricky."),(0,i.kt)("p",null,"T-Regx can always narrow down the error to the exact method to one particular call (even nested ones,\nlike malformed preg call inside ",(0,i.kt)("inlineCode",{parentName:"p"},"preg_replace_callback()"),"):"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-php"},"preg::replace_callback('pattern', function ($match) {  // this method won't throw exception\n    try {\n        return preg::replace_callback('({%invalid', 'strLen', '');  // this will throw exception\n    } catch (PregException $e) {\n        return '';  // it will be handled\n    }\n}, $subject); \n")),(0,i.kt)("p",null,"In short, ",(0,i.kt)("inlineCode",{parentName:"p"},"preg::")," can isolate the preg call to a single method call and not influence each other."),(0,i.kt)("h2",{id:"what-pattern-really-is"},"What ",(0,i.kt)("inlineCode",{parentName:"h2"},"Pattern")," really is"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"Pattern")," is a completely redesigned solution to using regular expressions in PHP. Software developer\nworking with ",(0,i.kt)("inlineCode",{parentName:"p"},"Pattern")," shouldn't know anything about ",(0,i.kt)("inlineCode",{parentName:"p"},"preg_match()"),",",(0,i.kt)("inlineCode",{parentName:"p"},"preg_replace()"),", etc. because built-in\nPHP ",(0,i.kt)("inlineCode",{parentName:"p"},"preg_")," methods are now nothing but an implementation detail. The interface of ",(0,i.kt)("inlineCode",{parentName:"p"},"Pattern")," is hermetic,\nno prior knowledge of ",(0,i.kt)("inlineCode",{parentName:"p"},"preg_")," is necessary."),(0,i.kt)("p",null,"We meet with comments, such that ",(0,i.kt)("inlineCode",{parentName:"p"},"Pattern")," is to ",(0,i.kt)("inlineCode",{parentName:"p"},"preg_match()")," what ",(0,i.kt)("inlineCode",{parentName:"p"},"PDO")," was to ",(0,i.kt)("inlineCode",{parentName:"p"},"mysql_query()"),".\nWe don't exactly disagree."))}m.isMDXComponent=!0}}]);