"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[8434],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>h});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var p=r.createContext({}),s=function(e){var t=r.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=s(e.components);return r.createElement(p.Provider,{value:t},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,p=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),u=s(n),m=a,h=u["".concat(p,".").concat(m)]||u[m]||d[m]||o;return n?r.createElement(h,i(i({ref:t},c),{},{components:n})):r.createElement(h,i({ref:t},c))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=m;var l={};for(var p in t)hasOwnProperty.call(t,p)&&(l[p]=t[p]);l.originalType=e,l[u]="string"==typeof e?e:a,i[1]=l;for(var s=2;s<o;s++)i[s]=n[s];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},3906:(e,t,n)=>{n.r(t),n.d(t,{default:()=>u,frontMatter:()=>l,metadata:()=>p,toc:()=>s});var r=n(7462),a=n(3366),o=(n(7294),n(3905)),i=["components"],l={title:"Announcement - Prepared patterns revamp",author:"Daniel Wilkowski"},p={permalink:"/blog/2021/07/10/revamp-announcement",source:"@site/blog/2021-07-10-revamp-announcement.md",title:"Announcement - Prepared patterns revamp",description:"Rawwrrrr!",date:"2021-07-10T00:00:00.000Z",formattedDate:"July 10, 2021",tags:[],readingTime:2.215,truncated:!1,prevItem:{title:"T-Regx on Gitter",permalink:"/blog/2021/11/10/gitter"},nextItem:{title:"Announcement - Prepared patterns simplification",permalink:"/blog/2021/07/10/simplification-of-prepared-patterns"}},s=[],c={toc:s};function u(e){var t=e.components,n=(0,a.Z)(e,i);return(0,o.kt)("wrapper",(0,r.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"Rawwrrrr!"),(0,o.kt)("p",null,"Hello, dear regexp writers! For about 5 months now, we've been working really hard or\nrewriting prepared patterns, in order to introduce certain necessary features to them."),(0,o.kt)("p",null,"The biggest issue, of prepared patterns in their current form, is that the only form\nof ignoring a placeholder in a pattern was escape."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-php"},"Pattern::inject('foo:@', ['bar']); // includes value\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-php"},"Pattern::inject('foo:\\@', []); // doesn't include value\n")),(0,o.kt)("p",null,"Of course, you could also escape the slash, so ",(0,o.kt)("inlineCode",{parentName:"p"},"foo:\\\\@")," would include the value, ",(0,o.kt)("inlineCode",{parentName:"p"},"foo:\\\\\\@"),"\nwouldn't, and so on."),(0,o.kt)("p",null,"The that's fine, but it's not everything. There are other cases whether placeholders needed\nspecial treatments, most notably ",(0,o.kt)("inlineCode",{parentName:"p"},"[@]"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"\\Q@\\E"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"(?#@)")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"#@\\n")," (with ",(0,o.kt)("inlineCode",{parentName:"p"},"x")," flag).\nWe knew about those cases, and we made sure, that while the placeholder would be used in those\ncases, they wouldn't break the pattern and wouldn't introduce any unexpected behaviour."),(0,o.kt)("p",null,"So in other words, as long as the users used the library according to the documentation, every\nthing would be fine and every feature would be usable as usual."),(0,o.kt)("p",null,"The problem appears, what if user uses the library not in accordance to the documentation?\nWell, the best case would be to throw an exception, where users' actions were invalid, or\nperform them if they were. Sadly, it turns out that with the current implementation that appeared\nto be impossible. And there's also another case, where user can use in-pattern structures to\nenable or disable ",(0,o.kt)("inlineCode",{parentName:"p"},"x")," flag, turning a certain pattern into a comment, or turn a comment off.\nIn that, handling the placeholder properly turned out to be virtually impossible, not for the\ncorner cases but for the standard cases as well.  So we decided to spend months, to rewrite the\nprepared patterns internals, allowing us to handle the pattern building process much better."),(0,o.kt)("p",null,"The changes haven't been released yet, but they will be soon. Here are the changes:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Currently, ",(0,o.kt)("inlineCode",{parentName:"li"},"\\@")," would be left untouched. This behaviour is unchanged."),(0,o.kt)("li",{parentName:"ul"},"Currently, ",(0,o.kt)("inlineCode",{parentName:"li"},"[@]"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"\\Q@\\E"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"\\c@")," would be injected. These values won't be injected now."),(0,o.kt)("li",{parentName:"ul"},"Currently, placeholder ",(0,o.kt)("inlineCode",{parentName:"li"},"@")," in comment would be injected. From now on, it won't, regardless of\nflags used in the main pattern, or in any of the subpatterns.")),(0,o.kt)("p",null,"So in short, in the current version, ",(0,o.kt)("inlineCode",{parentName:"p"},"@")," placeholder was replaced everytime, unless escaped."),(0,o.kt)("p",null,"In this the next release, ",(0,o.kt)("inlineCode",{parentName:"p"},"@")," will be replaced only if that's a literal in a pattern. So, if\n",(0,o.kt)("inlineCode",{parentName:"p"},"@")," is a part of a character-class (",(0,o.kt)("inlineCode",{parentName:"p"},"[@]"),"), is quoted (",(0,o.kt)("inlineCode",{parentName:"p"},"\\Q@\\E"),"), is escaped ",(0,o.kt)("inlineCode",{parentName:"p"},"\\@"),", is in a comment\n(",(0,o.kt)("inlineCode",{parentName:"p"},"(?#@)"),"), or is in an extended comment (",(0,o.kt)("inlineCode",{parentName:"p"},"#@\\n"),", when ",(0,o.kt)("inlineCode",{parentName:"p"},"x")," flag is used), then it won't be injected,\nor any other case to come, it won't be injected."))}u.isMDXComponent=!0}}]);